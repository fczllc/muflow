<!--
 * MuFlow - Vue Flow based flow chart editor
 * Copyright (c) 2024 tianyi
 * 
 * This project is based on Vue Flow (https://github.com/bcakmakoglu/vue-flow)
 * Vue Flow Copyright (c) bcakmakoglu - Released under MIT License
 * 
 * @license MIT
 -->

<template>
  <div class="flow-editor">
    <TopToolbar 
      @align="alignNodes"
      @distribute="distributeNodes"
      @layer="arrangeLayers"
    />
    <div class="main-content">
      <LeftSidebar :canvasTools="props.canvasTools" />
      <div class="canvas-container">
        <VueFlow
          :nodes="getNodes"
          :edges="getEdges"
          :node-types="nodeTypes"
          :default-viewport="{ x: 0, y: 0, zoom: 1 }"
          :connection-mode="ConnectionMode.Loose"
          :zoom-on-scroll="false"     
          :zoom-on-pinch="false" 
          :zoom-on-double-click="false"
          :pan-on-drag="false"
          :min-zoom="0.1"
          :max-zoom="2"
          :default-zoom="1"
          :pannable="false"
          :autoPanOnNodeDrag="false"
          :node-extent-pad="0"
          :snap-to-grid="false"
          :snap-grid="[2, 2]"
          :multi-selection-key-code="'Control'"
          :default-edge-options="{
            type: 'smoothstep',
            style: {
              strokeWidth: 1,
              stroke: '#555555'
            }
          }"
          class="vue-flow-wrapper"
          @connect="onConnectHandler"
          @drop="onDrop"
          @dragover="onDragOver"
          @nodeClick="onNodeClick"
          @edgeClick="onEdgeClick"
          @paneClick="onPaneClick"
          @paneDoubleClick="onPaneDoubleClick"
          @paneMousedown="onPaneMouseDown"
          @paneMousemove="onPaneMouseMove"
          @paneMouseup="onPaneMouseUp"
          @nodeDrag="onNodeDrag"
          @nodeDragStop="handleNodeDragStop"
          @selectionChange="onSelectionChange"
          @edge-double-click="onEdgeDoubleClick"
          :prevent-scrolling="true"
          :auto-connect="false"
          :elevate-edges-on-select="true"
          :disable-pan-on-node-drag="true"
          :disable-zoom-on-scroll="true"
        >
          <!-- æ·»åŠ å¯¹é½çº¿ç»„ä»?-->
          <AlignmentLines :lines="alignmentLines" />
          
          <!-- æ·»åŠ ç‹¬ç«‹çš„é€‰æ‹©æ¡†div -->
          <div id="selection-box" class="selection-area" style="display: none; position: absolute;"></div>
          
          <!-- æ³¨å†Œè‡ªå®šä¹‰èŠ‚ç‚?-->
          <template #node-roundedRect="nodeProps">
            <RoundedRectNode v-bind="nodeProps" />
          </template>
          <template #node-textLabel="nodeProps">
            <TextLabelNode v-bind="nodeProps" />
          </template>
          <template #node-line="nodeProps">
            <LineNode v-bind="nodeProps" />
          </template>
          <template #node-startEnd="nodeProps">
            <StartEndNode v-bind="nodeProps" />
          </template>
          <template #node-condition="nodeProps">
            <ConditionNode v-bind="nodeProps" />
          </template>
          <template #node-circle="nodeProps">
            <CircleNode v-bind="nodeProps" />
          </template>
          <template #node-svgIcon="nodeProps">
            <SvgIconNode v-bind="nodeProps" />
          </template>
        </VueFlow>
      </div>
    </div>
    
    <!-- è¾¹æ ‡ç­¾ç¼–è¾‘å¯¹è¯æ¡† -->
    <div v-if="showEdgeLabelDialog" class="edge-label-dialog-overlay" @click.self="cancelEdgeLabel">
      <div class="edge-label-dialog">
        <div class="dialog-header">
          <h3>ç¼–è¾‘è¿çº¿æ ‡ç­¾</h3>
        </div>
        <div class="dialog-body">
          <input 
            ref="edgeLabelInputRef"
            v-model="edgeLabelInput"
            type="text" 
            class="label-input"
            @keydown.enter="confirmEdgeLabel(edgeLabelInput)"
            @keydown.esc="cancelEdgeLabel"
            @keydown.delete.stop
            @keydown.backspace.stop
            placeholder="è¯·è¾“å…¥æ ‡ç­¾æ–‡æœ?
          />
        </div>
        <div class="dialog-footer">
          <button class="cancel-btn" @click="cancelEdgeLabel">å–æ¶ˆ</button>
          <button class="confirm-btn" @click="confirmEdgeLabel(edgeLabelInput)">ç¡®å®š</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'FlowEditor'
})
</script>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, markRaw, computed, nextTick, provide } from 'vue'
import { 
  VueFlow, 
  useVueFlow, 
  ConnectionMode, 
  MarkerType
} from '@vue-flow/core'
import type { 
  Connection, 
  NodeDragEvent, 
  NodeMouseEvent, 
  EdgeMouseEvent, 
  Node
} from '@vue-flow/core'
import TopToolbar from './Toolbar/TopToolbar.vue'
import LeftSidebar from './Sidebar/LeftSidebar.vue'
import RoundedRectNode from './Nodes/RoundedRectNode.vue'
import TextLabelNode from './Nodes/TextLabelNode.vue'
import LineNode from './Nodes/LineNode.vue'
import StartEndNode from './Nodes/StartEndNode.vue'
import ConditionNode from './Nodes/ConditionNode.vue'
import CircleNode from './Nodes/CircleNode.vue'
import SvgIconNode from './Nodes/SvgIconNode.vue'
import AlignmentLines from './AlignmentLines.vue'
import type { FlowNode, AlignDirection, DistributeDirection, NodeDimensions } from '../types/flow'
import { debounce } from 'lodash-es'
// å¼•å…¥å¿…è¦çš„æ ·å¼?import '@vue-flow/core/dist/style.css'
import '@vue-flow/core/dist/theme-default.css'
// å¯¼å…¥html-to-imageåº?import { toJpeg, toPng } from 'html-to-image'
// è‡ªå®šä¹‰NodeComponentç±»å‹ä»¥è§£å†³ç±»å‹å…¼å®¹æ€§é—®é¢?type NodeComponent = any

// å®šä¹‰ç”»å¸ƒå·¥å…·å±æ€§æ¥å?interface CanvasToolsConfig {
  clear?: boolean
  export?: boolean
  import?: boolean
  saveLocal?: boolean
  saveAPI?: boolean
  help?: boolean
}

// å®šä¹‰ç»„ä»¶å±æ€?interface Props {
  canvasTools?: CanvasToolsConfig
}

// è®¾ç½®é»˜è®¤å±æ€§å€?const props = withDefaults(defineProps<Props>(), {
  canvasTools: () => ({
    clear: true,
    export: true,
    import: true,
    saveLocal: true,
    saveAPI: true,
    help: true,
  })
})

// æä¾›canvasToolsé…ç½®ç»™å­ç»„ä»¶
provide('canvasTools', props.canvasTools)

// è·å– Vue Flow å®ä¾‹å’Œæ–¹æ³?const { 
  findNode, 
  getNodes, 
  getEdges, 
  getViewport, 
  getTransform,
  setNodes, 
  setEdges,
  addNodes, 
  addEdges, 
  updateEdge, 
  removeNodes, 
  removeEdges, 
  onConnect,
  onNodeDragStop: registerNodeDragStop, 
  onEdgeClick: registerEdgeClick,
  updateNodeInternals, // ç¡®ä¿è¿™ä¸ªæ–¹æ³•è¢«æ­£ç¡®å¯¼å…?  project,
  viewportRef,
  fitView,
  getNodeTypes,
  updateNode, // æ·»åŠ updateNodeæ–¹æ³•
} = useVueFlow()

// çŠ¶æ€å®šä¹?const selectedNodeId = ref<string | null>(null)
const selectedEdgeId = ref<string | null>(null)
const recentlyClickedEdge = ref(false)
const pendingConnection = ref<Connection | null>(null)
const isResizing = ref(false)
const resizeJustEnded = ref(false)
const componentMountedRef = ref(true) // ç»„ä»¶æŒ‚è½½çŠ¶æ€è·Ÿè¸?const resizeEndTimeoutRef = ref<ReturnType<typeof setTimeout> | null>(null) // ç”¨äºå­˜å‚¨resize-endäº‹ä»¶å¤„ç†çš„timeoutå¼•ç”¨
const selectedNodes = ref<string[]>([])
const alignmentLines = ref<Array<{ id: string; type: 'horizontal' | 'vertical'; position: number }>>([])
const snapThreshold = 2
const nodeDimensionsCache = new Map<string, NodeDimensions>()
const nodeCenterMap = new Map<string, {x: number, y: number}>()

// åŒºåŸŸé€‰æ‹©ç›¸å…³çŠ¶æ€?const isSelecting = ref(false)
const startPoint = ref<{ x: number, y: number } | null>(null)
const currentPoint = ref<{ x: number, y: number } | null>(null)
const selectionBoxRef = ref<HTMLElement | null>(null)

// æ·»åŠ å‰ªè´´æ¿çŠ¶æ€?interface ClipboardItem {
  type: 'node'
  data: {
    id: string
    type: string
    position: { x: number; y: number }
    data?: {
      label?: string
      fontSize?: number
      color?: string
      style?: Record<string, any>
      draggable?: boolean
      selectable?: boolean
      connectable?: boolean
      [key: string]: any
    }
  }
}
const clipboard = ref<ClipboardItem[]>([])

// æ·»åŠ å†å²è®°å½•çŠ¶æ€?interface HistoryState {
  nodes: FlowNode[]
  edges: any[]
}

const history = ref<HistoryState[]>([])
const currentHistoryIndex = ref(-1)

// æ³¨å†Œè‡ªå®šä¹‰èŠ‚ç‚¹ç±»å?const nodeTypes = markRaw({
  roundedRect: RoundedRectNode,
  textLabel: TextLabelNode,
  line: LineNode,
  startEnd: StartEndNode,
  condition: ConditionNode,
  circle: CircleNode,
  svgIcon: SvgIconNode
})

// è®¡ç®—å±æ€?const selectedNodesList = computed(() => 
  getNodes.value.filter(node => node.selected)
)

const selectedNodesBounds = computed(() => {
  if (selectedNodesList.value.length < 2) return null
  
  const initialBounds = {
    left: Infinity,
    right: -Infinity,
    top: Infinity,
    bottom: -Infinity
  }
  
  return selectedNodesList.value.reduce<typeof initialBounds>((acc, node) => {
    if (!isFlowNode(node)) return acc
    const { width, height } = getNodeDimensions(node)
    return {
      left: Math.min(acc.left, node.position.x),
      right: Math.max(acc.right, node.position.x + width),
      top: Math.min(acc.top, node.position.y),
      bottom: Math.max(acc.bottom, node.position.y + height)
    }
  }, initialBounds)
})

// é€‰æ‹©åŒºåŸŸæ ·å¼è®¡ç®—
const selectAreaStyle = computed(() => {
  if (!startPoint.value || !currentPoint.value) return {}
  
  const left = Math.min(startPoint.value.x, currentPoint.value.x)
  const top = Math.min(startPoint.value.y, currentPoint.value.y)
  const width = Math.abs(currentPoint.value.x - startPoint.value.x)
  const height = Math.abs(currentPoint.value.y - startPoint.value.y)
  
  return {
    left: `${left}px`,
    top: `${top}px`,
    width: `${width}px`,
    height: `${height}px`
  }
})

// å·¥å…·æ–¹æ³•
const getDefaultLabel = (type: string): string => {
  switch (type) {
    case 'textLabel': return 'æ–‡æœ¬'
    case 'roundedRect': return 'èŠ‚ç‚¹'
    case 'line': return 'ç›´çº¿'
    case 'startEnd': return 'èµ·æ­¢èŠ‚ç‚¹'
    case 'condition': return 'æ¡ä»¶èŠ‚ç‚¹'
    case 'circle': return ''
    case 'svgIcon': return '' // SVGå›¾æ ‡èŠ‚ç‚¹é»˜è®¤æ— æ ‡ç­?    default: return 'èŠ‚ç‚¹'
  }
}

const isFlowNode = (node: any): node is FlowNode => {
  return node && 
    typeof node.id === 'string' && 
    typeof node.type === 'string' &&
    typeof node.position === 'object' &&
    'data' in node
}

const getNodeDimensions = (node: any): NodeDimensions => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor')) {
    // è¿”å›é»˜è®¤å°ºå¯¸ä»¥é¿å…é”™è¯?    return {
      width: node.type === 'textLabel' ? 150 : 200,
      height: node.type === 'textLabel' ? 40 : 50
    };
  }
  
  const cached = nodeDimensionsCache.get(node.id);
  if (cached) return cached;
  
  // é¦–å…ˆæŸ¥æ‰¾Vue FlowèŠ‚ç‚¹å®¹å™¨
  const element = document.querySelector(`[data-id="${node.id}"]`);
  if (element) {
    // åœ¨Vue FlowèŠ‚ç‚¹å®¹å™¨å†…æŸ¥æ‰¾å®é™…èŠ‚ç‚¹ç»„ä»?    // ä¾‹å¦‚ï¼?rounded-rect-node, .condition-nodeç­?    const innerElement = element.querySelector('.rounded-rect-node, .start-end-node, .condition-node, .circle-node, .text-label-node, .line-node, .svg-icon-node');
    
    // å¦‚æœæ‰¾åˆ°å†…éƒ¨èŠ‚ç‚¹ç»„ä»¶ï¼Œä½¿ç”¨å®ƒçš„å°ºå¯?    if (innerElement) {
      const rect = innerElement.getBoundingClientRect();
      const dimensions = {
        width: Math.round(rect.width),
        height: Math.round(rect.height)
      };
      nodeDimensionsCache.set(node.id, dimensions);
      return dimensions;
    }
    
    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å†…éƒ¨ç»„ä»¶ï¼Œè¿”å›åˆ°ä½¿ç”¨Vue Flowå®¹å™¨çš„å°ºå¯?    const rect = element.getBoundingClientRect();
    const dimensions = {
      width: Math.round(rect.width),
      height: Math.round(rect.height)
    };
    nodeDimensionsCache.set(node.id, dimensions);
    return dimensions;
  }
  
  // å¦‚æœæ‰¾ä¸åˆ°DOMå…ƒç´ ï¼Œä½¿ç”¨é»˜è®¤å°ºå¯?  const defaultDimensions = {
    width: node.type === 'textLabel' ? 150 : 200,
    height: node.type === 'textLabel' ? 40 : 50
  };
  
  nodeDimensionsCache.set(node.id, defaultDimensions);
  return defaultDimensions;
};

const clearNodeDimensionsCache = (nodeId: string) => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor')) {
    return;
  }
  
  nodeDimensionsCache.delete(nodeId);
  nodeCenterMap.delete(nodeId);
};

// æ›´æ–°èŠ‚ç‚¹ä¸­å¿ƒç‚¹åæ ?const updateNodeCenter = (node: any) => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor') || !node || !node.id) {
    return;
  }
  
  const { width, height } = getNodeDimensions(node);
  // ç›´æ¥ä½¿ç”¨ç²¾ç¡®è®¡ç®—å€¼ï¼Œä¸è¿›è¡Œå››èˆäº”å…?  const centerX = node.position.x + width / 2;
  const centerY = node.position.y + height / 2;
  
  // å­˜å‚¨ç²¾ç¡®çš„ä¸­å¿ƒç‚¹åæ ‡
  nodeCenterMap.set(node.id, {x: centerX, y: centerY});
};

// ä¿®æ”¹é˜²æŠ–å‡½æ•°ï¼Œç¡®ä¿ç»„ä»¶å¸è½½æ—¶ä¸ä¼šç»§ç»­æ‰§è¡Œ
const initNodeCenters = debounce(() => {
  try {
    // åœ¨æ‰§è¡Œæ›´æ–°å‰æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?    if (!document.querySelector('.flow-editor')) {
      return false; // å¦‚æœç»„ä»¶å·²å¸è½½ï¼Œä¸æ‰§è¡Œæ›´æ–?    }
    
    getNodes.value.forEach(node => {
      // ç›´æ¥ä½¿ç”¨èŠ‚ç‚¹çš„åŸå§‹ä½ç½®ï¼Œä¸è¿›è¡Œå››èˆäº”å…?      updateNodeCenter(node);
    });
    
    return true; // è¡¨ç¤ºæ‰§è¡ŒæˆåŠŸ
  } catch (error) {
    // é”™è¯¯å¤„ç†ä½†ä¸è¾“å‡ºæ—¥å¿—
    return false;
  }
}, 100);

// æ·»åŠ observeNodeså‡½æ•°ï¼Œç›‘å¬èŠ‚ç‚¹å˜åŒ–ï¼Œä¼˜åŒ–æ‰§è¡Œé€»è¾‘
const observeNodes = () => {
  // åœ¨æ‰§è¡Œæ£€æŸ¥å‰ç¡®è®¤ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ¨
  if (!document.querySelector('.flow-editor')) {
    return false; // å¦‚æœç»„ä»¶å·²å¸è½½ï¼Œè¿”å›falseè¡¨ç¤ºä¸å†ç»§ç»­æ‰§è¡Œ
  }
  
  // åªæœ‰å½“èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–æ—¶æ‰æ›´æ–°ä¸­å¿ƒç‚¹
  const currentNodesCount = getNodes.value.length;
  if (currentNodesCount > 0) {
    initNodeCenters();
  }
  return true; // è¿”å›trueè¡¨ç¤ºå‡½æ•°æ‰§è¡ŒæˆåŠŸ
}

// å¯¹é½å’Œåˆ†å¸ƒæ–¹æ³?const alignNodes = (direction: AlignDirection) => {
  const bounds = selectedNodesBounds.value
  if (!bounds) return
  
  const centerX = bounds.left + (bounds.right - bounds.left) / 2
  const centerY = bounds.top + (bounds.bottom - bounds.top) / 2
  
  const nodes = getNodes.value.map(node => {
    if (!isFlowNode(node) || !node.selected) return node
    
    const { width, height } = getNodeDimensions(node)
    let newPosition = { x: node.position.x, y: node.position.y }
    
    switch (direction) {
      case 'left':
        newPosition.x = bounds.left
        break
      case 'right':
        newPosition.x = bounds.right - width
        break
      case 'top':
        newPosition.y = bounds.top
        break
      case 'bottom':
        newPosition.y = bounds.bottom - height
        break
      case 'center':
        newPosition.x = centerX - width / 2
        break
      case 'middle':
        newPosition.y = centerY - height / 2
        break
    }
    
    return { ...node, position: newPosition }
  })
  
  setNodes(nodes)
}

const distributeNodes = (direction: DistributeDirection) => {
  if (selectedNodesList.value.length < 3) return
  
  try {
    const nodesInfo = selectedNodesList.value.map((node) => {
      if (!isFlowNode(node)) {
        throw new Error(`Invalid node type for ${node.id}`)
      }
      
      const { width, height } = getNodeDimensions(node)
      return {
        id: node.id,
        width,
        height,
        position: node.position,
        center: direction === 'horizontal' 
          ? node.position.x + width / 2 
          : node.position.y + height / 2
      }
    })
    
    // æŒ‰ä¸­å¿ƒç‚¹ä½ç½®æ’åº
    nodesInfo.sort((a, b) => a.center - b.center)
    
    // è·å–é¦–å°¾èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹ä½ç½®
    const firstCenter = nodesInfo[0].center
    const lastCenter = nodesInfo[nodesInfo.length - 1].center
    
    // è®¡ç®—é—´è·
    const totalSpace = lastCenter - firstCenter
    const spacing = totalSpace / (nodesInfo.length - 1)
    
    // æ›´æ–°èŠ‚ç‚¹ä½ç½®
    const nodes = getNodes.value.map(node => {
      const nodeInfo = nodesInfo.find(info => info.id === node.id)
      if (!nodeInfo || !node.selected) return node
      
      const index = nodesInfo.findIndex(info => info.id === node.id)
      if (index === 0 || index === nodesInfo.length - 1) return node
      
      const newCenter = firstCenter + spacing * index
      const newPosition = { ...node.position }
      
      if (direction === 'horizontal') {
        newPosition.x = newCenter - nodeInfo.width / 2
      } else {
        newPosition.y = newCenter - nodeInfo.height / 2
      }
      
      return { ...node, position: newPosition }
    })
    
    setNodes(nodes)
  } catch (error) {
    console.error('Failed to distribute nodes:', error)
  }
}

// æ·»åŠ ä¿å­˜å†å²è®°å½•çš„æ–¹æ³?const saveToHistory = () => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor')) {
    return;
  }
  
  // å¦‚æœå½“å‰ä¸åœ¨å†å²è®°å½•çš„æœ€åï¼Œåˆ é™¤å½“å‰ä½ç½®ä¹‹åçš„è®°å½?  if (currentHistoryIndex.value < history.value.length - 1) {
    history.value = history.value.slice(0, currentHistoryIndex.value + 1);
  }
  
  // è·å–å½“å‰èŠ‚ç‚¹å’Œè¾¹çš„çŠ¶æ€ï¼Œç¡®ä¿é€‰ä¸­çŠ¶æ€æ˜¯æ­£ç¡®çš?  const currentNodes = getNodes.value.map(node => {
    // ä¿ç•™èŠ‚ç‚¹çš„é€‰ä¸­çŠ¶æ€ï¼Œè¿™æ ·æ’¤é”€åå¯ä»¥æ¢å¤åˆ°æ­£ç¡®çš„é€‰ä¸­çŠ¶æ€?    return { ...node };
  });
  
  const currentEdges = getEdges.value.map(edge => {
    // ä¿ç•™è¾¹çš„é€‰ä¸­çŠ¶æ€?    return { ...edge };
  });
  
  // ä¿å­˜å½“å‰çŠ¶æ€?  history.value.push({
    nodes: JSON.parse(JSON.stringify(currentNodes)),
    edges: JSON.parse(JSON.stringify(currentEdges))
  });
  currentHistoryIndex.value = history.value.length - 1;
  
  // é™åˆ¶å†å²è®°å½•æ•°é‡ï¼Œæœ€å¤šä¿å­?0æ­?  if (history.value.length > 10) {
    history.value.shift();
    currentHistoryIndex.value--;
  }
};

// æä¾›addNodeså’ŒsaveToHistoryå‡½æ•°ç»™å­ç»„ä»¶ä½¿ç”¨
provide('addNodes', addNodes)
provide('saveToHistory', saveToHistory)

// æ·»åŠ æ¸…ç©ºç”»å¸ƒçš„æ–¹æ³?const clearCanvas = () => {
  setNodes([])
  setEdges([])
  saveToHistory()
}

// æä¾›clearCanvasæ–¹æ³•ç»™å­ç»„ä»¶ä½¿ç”¨
provide('clearCanvas', clearCanvas)

// åœ¨script setupéƒ¨åˆ†æ·»åŠ æ¨¡æ€å¯¹è¯æ¡†ç›¸å…³çš„å˜é‡?const showEdgeLabelDialog = ref(false)
const currentEditingEdge = ref<any>(null)
const edgeLabelInput = ref('')
const edgeLabelInputRef = ref<HTMLInputElement | null>(null)

// æ·»åŠ å¯¹æ¡†é€‰èŠ‚ç‚¹çŠ¶æ€çš„è·Ÿè¸ª
const selectedNodesViaAreaSelection = ref<string[]>([]);

// ä¿®æ”¹onConnectHandlerå‡½æ•°ï¼Œåœ¨åˆ›å»ºæ–°è¾¹æ—¶é»˜è®¤æ·»åŠ ç©ºæ ‡ç­¾
const onConnectHandler = (connection: Connection) => {
  // å…ˆä¿å­˜å½“å‰çŠ¶æ€?  saveToHistory()
  
  const edgeId = `e${connection.source}-${connection.target}`
  
  const edge = {
    id: edgeId,
    source: connection.source,
    target: connection.target,
    sourceHandle: connection.sourceHandle,
    targetHandle: connection.targetHandle,
    type: 'smoothstep',
    style: {
      strokeWidth: 1,
      stroke: '#555555'
    },
    markerEnd: {
      type: MarkerType.Arrow,
      color: '#555555',
      width: 15,
      height: 15,
      strokeWidth: 2
    },
    data: {
      savedLineWidth: 1,
      savedLineColor: '#555555',
      savedLineStyle: 'solid',
      savedArrowStyle: 'target',
      label: ''  // ç¡®ä¿æ¯æ¡è¾¹éƒ½æœ‰ä¸€ä¸ªç©ºæ ‡ç­¾
    },
    label: ''  // é»˜è®¤ç©ºæ ‡ç­?  }
  
  addEdges([edge])
}

const onDragOver = (event: DragEvent) => {
  event.preventDefault()
  if (event.dataTransfer) {
    event.dataTransfer.dropEffect = 'move'
  }
}

const onDrop = (event: DragEvent) => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor')) {
    return;
  }
  
  const nodeTypeData = event.dataTransfer?.getData('application/vueflow')
  
  if (typeof nodeTypeData === 'string' && nodeTypeData) {
    let nodeType = nodeTypeData
    let iconType: string | undefined
    
    // å°è¯•è§£æJSONæ•°æ®ï¼Œæ”¯æŒä»å›¾æ ‡é€‰æ‹©å™¨æ‹–æ‹?    try {
      const parsedData = JSON.parse(nodeTypeData)
      if (parsedData && typeof parsedData === 'object') {
        nodeType = parsedData.nodeType || nodeType
        iconType = parsedData.iconType
      }
    } catch {
      // å¦‚æœè§£æå¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸå§‹nodeType
    }
    
    const { left, top } = (event.target as HTMLDivElement).getBoundingClientRect()
    const position = project({
      x: event.clientX - left,
      y: event.clientY - top,
    })

    // ä¿ç•™ä¸€ä½å°æ•°å¹¶ç¡®ä¿æ•´æ•°éƒ¨åˆ†æ˜¯å¶æ•?    let x = Number(position.x.toFixed(1));
    let y = Number(position.y.toFixed(1));
    
    // å¦‚æœæ•´æ•°éƒ¨åˆ†æ˜¯å¥‡æ•°ï¼Œåˆ™è°ƒæ•´ä¸ºå¶æ•°
    if (Math.floor(x) % 2 !== 0) {
      x = Number((Math.floor(x) + 1 + (x - Math.floor(x))).toFixed(1));
    }
    if (Math.floor(y) % 2 !== 0) {
      y = Number((Math.floor(y) + 1 + (y - Math.floor(y))).toFixed(1));
    }

    let newNode: Node = {
      id: `${nodeType}-${getNodes.value.length + 1}`,
      type: nodeType,
      position: { x, y },
      data: { 
        label: getDefaultLabel(nodeType),
        // ä¸ºæ‰€æœ‰èŠ‚ç‚¹åˆå§‹åŒ–æ ·å¼å¯¹è±¡
        style: {
          width: nodeType === 'circle' ? '38px' : '100px',
          height: nodeType === 'circle' ? '38px' : nodeType === 'condition' ? '60px' : '38px',
          textAlign: 'center',
          fontWeight: 'normal',
          fontStyle: 'normal',
          textDecoration: 'none'
        }
      }
    }

    // ä¸ºç›´çº¿èŠ‚ç‚¹è®¾ç½®ç‰¹æ®Šå±æ€?    if (nodeType === 'line') {
      newNode = {
        ...newNode,
        data: {
          ...newNode.data,
          style: {
            strokeWidth: 1,
            stroke: '#000000',
            strokeDasharray: ''
          }
        },
        draggable: true,
        selectable: true
      }
    }
    
    // ä¸ºSVGå›¾æ ‡èŠ‚ç‚¹è®¾ç½®å±æ€?    if (nodeType === 'svgIcon' && iconType) {
      newNode = {
        ...newNode,
        data: {
          iconType,
          width: 24,
          height: 24,
          strokeWidth: 2,
          color: '#333333'
        },
        draggable: true,
        selectable: true,
        connectable: false
      }
    }

    // æ·»åŠ æ–°èŠ‚ç‚?    addNodes([newNode])
    
    // ä½¿ç”¨setTimeoutæ¥ç¡®ä¿DOMå·²æ›´æ–?    setTimeout(() => {
      // å†æ¬¡æ£€æŸ¥ç»„ä»¶æ˜¯å¦å­˜åœ?      if (!document.querySelector('.flow-editor')) {
        return;
      }
      // ç«‹å³æ›´æ–°ä¸­å¿ƒç‚¹Map
      updateNodeCenter(newNode);
      
      // å–æ¶ˆé€‰ä¸­å…¶ä»–èŠ‚ç‚¹ï¼Œåªé€‰ä¸­æ–°æ·»åŠ çš„èŠ‚ç‚¹
      const nodes = getNodes.value.map(node => ({
        ...node,
        selected: node.id === newNode.id
      }));
      setNodes(nodes);
      
      // åœ¨æ·»åŠ èŠ‚ç‚¹åä¿å­˜å†å²è®°å½•
      saveToHistory();
    }, 10);
  }
}

const onNodeClick = (event: NodeMouseEvent) => {
  event.event?.stopPropagation()
  
  const { node } = event
  selectedNodeId.value = node.id
  selectedEdgeId.value = null
  
  const nodes = getNodes.value.map(n => ({
    ...n,
    selected: n.id === node.id
  }))
  
  const edges = getEdges.value.map(e => ({
    ...e,
    selected: false
  }))
  
  setNodes(nodes)
  setEdges(edges)
}

const onEdgeClick = (event: EdgeMouseEvent) => {
  event.event?.preventDefault()
  event.event?.stopPropagation()
  
  const { edge } = event
  
  recentlyClickedEdge.value = true
  
  setTimeout(() => {
    recentlyClickedEdge.value = false
  }, 200)
  
  const nodes = getNodes.value.map(n => ({
    ...n,
    selected: false
  }))
  
  const edges = getEdges.value.map(e => ({
    ...e,
    selected: e.id === edge.id
  }))
  
  setNodes(nodes)
  setEdges(edges)
  selectedEdgeId.value = edge.id
  selectedNodeId.value = null
}

// å®šä¹‰ä¸€ä¸ªå…¬å…±å‡½æ•°æ¥å¤„ç†å–æ¶ˆé€‰æ‹©å’Œç¼–è¾‘çŠ¶æ€?const clearSelectionAndEditingState = () => {
  // æ¸…é™¤æ‰€æœ‰æ–‡æœ¬é€‰æ‹©
  window.getSelection()?.removeAllRanges()
  
  // æ£€æŸ¥æ˜¯å¦æœ‰èŠ‚ç‚¹å¤„äºç¼–è¾‘çŠ¶æ€?  const nodesInEditingState = getNodes.value.filter(node => 
    node.data && node.data.isEditing === true
  )
  
  // å¦‚æœæœ‰èŠ‚ç‚¹å¤„äºç¼–è¾‘çŠ¶æ€ï¼Œé€€å‡ºç¼–è¾‘çŠ¶æ€?  if (nodesInEditingState.length > 0) {
    const updatedNodes = getNodes.value.map(node => {
      if (node.data && node.data.isEditing === true) {
        // ä¿ç•™èŠ‚ç‚¹ç¼–è¾‘å‰çš„å…¶ä»–æ•°æ®ï¼Œä»…æ›´æ–°isEditingçŠ¶æ€?        return {
          ...node,
          data: {
            ...node.data,
            isEditing: false
          }
        }
      }
      return node
    })
    
    setNodes(updatedNodes)
    
    // å¼ºåˆ¶æ›´æ–°è¿™äº›èŠ‚ç‚¹çš„å†…éƒ¨ç»“æ?    nodesInEditingState.forEach(node => {
      updateNodeInternals([node.id])
    })
  }
  
  // å–æ¶ˆæ‰€æœ‰èŠ‚ç‚¹å’Œè¾¹çš„é€‰ä¸­çŠ¶æ€?  const nodes = getNodes.value.map(n => ({
    ...n,
    selected: false
  }))
  
  const edges = getEdges.value.map(e => ({
    ...e,
    selected: false
  }))
  
  setNodes(nodes)
  setEdges(edges)
  
  selectedNodeId.value = null
  selectedEdgeId.value = null
}

// ä¿®æ”¹onPaneClickå‡½æ•°
const onPaneClick = (event: MouseEvent) => {
  // å¦‚æœæ­£åœ¨è¿›è¡ŒåŒºåŸŸé€‰æ‹©ï¼Œä¸å¤„ç†ç‚¹å‡»äº‹ä»¶
  if (isSelecting.value) return
  
  if (recentlyClickedEdge.value || isResizing.value || resizeJustEnded.value) {
    resizeJustEnded.value = false
    return
  }
  
  // ä½¿ç”¨å…¬å…±å‡½æ•°å–æ¶ˆé€‰æ‹©å’Œç¼–è¾‘çŠ¶æ€?  clearSelectionAndEditingState()
}

// ä¿®æ”¹onPaneDoubleClickå‡½æ•°
const onPaneDoubleClick = (event: MouseEvent) => {
  // ä½¿ç”¨å…¬å…±å‡½æ•°å–æ¶ˆé€‰æ‹©å’Œç¼–è¾‘çŠ¶æ€?  clearSelectionAndEditingState()
}

// å¯¹é½ç®—æ³•ï¼Œä½¿ç”¨ä¸­å¿ƒç‚¹Mapè¿›è¡Œå¯¹é½è®¡ç®—
const calculateAlignment = (draggedNode: any) => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor')) {
    return [];
  }
  
  if (!draggedNode || !draggedNode.id || nodeCenterMap.size <= 1) return [];
  
  // è·å–å½“å‰æ‹–åŠ¨èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹
  const draggedCenter = nodeCenterMap.get(draggedNode.id);
  if (!draggedCenter) {
    // å¦‚æœMapä¸­æ²¡æœ‰å½“å‰èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹ï¼Œå…ˆæ›´æ–°ä¸€ä¸?    updateNodeCenter(draggedNode);
    const updatedDraggedCenter = nodeCenterMap.get(draggedNode.id);
    if (!updatedDraggedCenter) return [];
    return [];
  }

  const alignmentLines: Array<{id: string; type: 'horizontal' | 'vertical'; position: number}> = [];
  let closestVertical = {nodeId: '', diff: Infinity, centerX: 0};
  let closestHorizontal = {nodeId: '', diff: Infinity, centerY: 0};
  
  // æŸ¥æ‰¾æœ€è¿‘çš„å‚ç›´å’Œæ°´å¹³å¯¹é½ç‚¹
  nodeCenterMap.forEach((center, nodeId) => {
    if (nodeId === draggedNode.id) return;
    
    // æ£€æŸ¥Xè½´å¯¹é½?å‚ç›´çº?
    const xDiff = Math.abs(center.x - draggedCenter.x);
    if (xDiff <= snapThreshold && xDiff < closestVertical.diff) {
      closestVertical = {nodeId, diff: xDiff, centerX: center.x};
    }
    
    // æ£€æŸ¥Yè½´å¯¹é½?æ°´å¹³çº?
    const yDiff = Math.abs(center.y - draggedCenter.y);
    if (yDiff <= snapThreshold && yDiff < closestHorizontal.diff) {
      closestHorizontal = {nodeId, diff: yDiff, centerY: center.y};
    }
  });
  
  // æ·»åŠ å‚ç›´å¯¹é½çº?- ä½¿ç”¨ç›®æ ‡èŠ‚ç‚¹çš„Xåæ ‡
  if (closestVertical.nodeId) {
    alignmentLines.push({
      id: `v-${closestVertical.nodeId}`,
      type: 'vertical',
      position: closestVertical.centerX // å¯¹é½çº¿Xåæ ‡ä½¿ç”¨ç›®æ ‡èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹X
    });
  }
  
  // æ·»åŠ æ°´å¹³å¯¹é½çº?- ä½¿ç”¨ç›®æ ‡èŠ‚ç‚¹çš„Yåæ ‡
  if (closestHorizontal.nodeId) {
    alignmentLines.push({
      id: `h-${closestHorizontal.nodeId}`,
      type: 'horizontal',
      position: closestHorizontal.centerY // å¯¹é½çº¿Yåæ ‡ä½¿ç”¨ç›®æ ‡èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹Y
    });
  }
  
  return alignmentLines;
};

// ä¿®æ”¹applySnapå‡½æ•°ï¼Œç¡®ä¿æ‰€æœ‰è®¡ç®—ç»“æœéƒ½æ˜¯ä¿ç•™ä¸€ä½å°æ•?const applySnap = (node: any, alignmentLines: any[]) => {
  // è·å–å½“å‰èŠ‚ç‚¹ä¸­å¿ƒç‚?  const nodeCenter = nodeCenterMap.get(node.id);
  if (!nodeCenter) {
    return node;
  }
  
  // è·å–èŠ‚ç‚¹å°ºå¯¸
  const { width, height } = node.dimensions || getNodeDimensions(node);
  
  // è®°å½•åŸå§‹ä½ç½®
  let { x, y } = node.position;
  let adjusted = false;
  
  // ä»alignmentLinesä¸­æ‰¾åˆ°æ°´å¹³å’Œå‚ç›´çº?  const horizontalLine = alignmentLines.find(line => line.type === 'horizontal');
  const verticalLine = alignmentLines.find(line => line.type === 'vertical');
  
  if (horizontalLine || verticalLine) {
    // æŸ¥æ‰¾æ‰€æœ‰è¦å¯¹é½çš„èŠ‚ç‚¹ID
    let targetNodeIdY = '';
    let targetNodeIdX = '';
    
    // éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ‰¾åˆ°ä¸å¯¹é½çº¿åŒ¹é…çš„èŠ‚ç‚?    nodeCenterMap.forEach((center, id) => {
      if (id === node.id) return;
      
      // å¦‚æœæ°´å¹³å¯¹é½çº¿çš„ä½ç½®ä¸èŠ‚ç‚¹ä¸­å¿ƒç‚¹Yåæ ‡æ¥è¿‘ï¼Œæ ‡è®°ä¸ºç›®æ ‡èŠ‚ç‚¹
      if (horizontalLine && Math.abs(horizontalLine.position - center.y) < 0.1) {
        targetNodeIdY = id;
      }
      
      // å¦‚æœå‚ç›´å¯¹é½çº¿çš„ä½ç½®ä¸èŠ‚ç‚¹ä¸­å¿ƒç‚¹Xåæ ‡æ¥è¿‘ï¼Œæ ‡è®°ä¸ºç›®æ ‡èŠ‚ç‚¹
      if (verticalLine && Math.abs(verticalLine.position - center.x) < 0.1) {
        targetNodeIdX = id;
      }
    });
    
    // åº”ç”¨æ°´å¹³å¯¹é½ï¼ˆä¸­å¿ƒç‚¹Yå¯¹é½ï¼?    if (horizontalLine && targetNodeIdY) {
      // è·å–ç›®æ ‡èŠ‚ç‚¹
      const targetNode = getNodes.value.find(n => n.id === targetNodeIdY);
      if (targetNode) {
        // ç±»ä¼¼äºalignNodesæ–¹æ³•ï¼Œç›´æ¥è®¡ç®—ç²¾ç¡®ä½ç½?        const targetNodeDim = getNodeDimensions(targetNode);
        const targetCenterY = targetNode.position.y + targetNodeDim.height / 2;
        
        // ç›´æ¥è®¡ç®—éœ€è¦è®¾ç½®çš„Yä½ç½®ï¼Œä½¿å¾—èŠ‚ç‚¹ä¸­å¿ƒç‚¹ä¸ç›®æ ‡ä¸­å¿ƒç‚¹å¯¹é½
        y = targetCenterY - height / 2;
        adjusted = true;
      }
    }
    
    // åº”ç”¨å‚ç›´å¯¹é½ï¼ˆä¸­å¿ƒç‚¹Xå¯¹é½ï¼?    if (verticalLine && targetNodeIdX) {
      // è·å–ç›®æ ‡èŠ‚ç‚¹
      const targetNode = getNodes.value.find(n => n.id === targetNodeIdX);
      if (targetNode) {
        // ç±»ä¼¼äºalignNodesæ–¹æ³•ï¼Œç›´æ¥è®¡ç®—ç²¾ç¡®ä½ç½?        const targetNodeDim = getNodeDimensions(targetNode);
        const targetCenterX = targetNode.position.x + targetNodeDim.width / 2;
        
        // ç›´æ¥è®¡ç®—éœ€è¦è®¾ç½®çš„Xä½ç½®ï¼Œä½¿å¾—èŠ‚ç‚¹ä¸­å¿ƒç‚¹ä¸ç›®æ ‡ä¸­å¿ƒç‚¹å¯¹é½
        x = targetCenterX - width / 2;
        adjusted = true;
      }
    }
  }
  
  // è¿”å›æ›´æ–°åçš„èŠ‚ç‚¹å¯¹è±¡ï¼ˆä¸ä¿®æ”¹åŸå§‹å¯¹è±¡ï¼?  return {
    ...node,
    position: { x, y }
  };
};

// ä¿®æ”¹onNodeDragå‡½æ•°ï¼Œæ·»åŠ æ—¥å¿?const onNodeDrag = (event: NodeDragEvent) => {
  try {
    const { node } = event;
    
    // ç›´æ¥ä½¿ç”¨èŠ‚ç‚¹ä½ç½®ï¼Œä¸å†è¿›è¡Œå››èˆäº”å…¥å’Œå¶æ•°åŒ–å¤„ç?    let newPosition = { ...node.position };
    
    // æ›´æ–°èŠ‚ç‚¹ä½ç½® - åˆ›å»ºæ–°çš„èŠ‚ç‚¹å¯¹è±¡
    const updatedNodes = getNodes.value.map(n => 
      n.id === node.id ? { ...n, position: newPosition } : n
    );
    
    // æ›´æ–°çŠ¶æ€?    setNodes(updatedNodes);
    
    // è·å–æ›´æ–°åçš„èŠ‚ç‚¹
    const updatedNode = updatedNodes.find(n => n.id === node.id);
    if (!updatedNode) return;
    
    // 1. æ›´æ–°æ‹–åŠ¨èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹åæ ‡
    updateNodeCenter(updatedNode);
    
    // 2. è®¡ç®—å½“å‰èŠ‚ç‚¹ä¸å…¶ä»–èŠ‚ç‚¹çš„å¯¹é½ä½ç½®
    const lines = calculateAlignment(updatedNode);
    
    // 3. æ›´æ–°å¯¹é½çº¿æ˜¾ç¤?    alignmentLines.value = lines;
    
    // 4. è·å–å½“å‰èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹
    const centerPoint = nodeCenterMap.get(updatedNode.id);
    if (centerPoint) {
      // æŸ¥æ‰¾æ‰€æœ‰Xåæ ‡å·®å°äº?pxçš„èŠ‚ç‚?      const closeNodesX = Array.from(nodeCenterMap.entries())
        .filter(([id, center]) => {
          if (id === updatedNode.id) return false;
          return Math.abs(center.x - centerPoint.x) <= 3;
        });
      
      // æŸ¥æ‰¾æ‰€æœ‰Yåæ ‡å·®å°äº?pxçš„èŠ‚ç‚?      const closeNodesY = Array.from(nodeCenterMap.entries())
        .filter(([id, center]) => {
          if (id === updatedNode.id) return false;
          return Math.abs(center.y - centerPoint.y) <= 3;
        });
    }
  } catch (error) {
    // é”™è¯¯å¤„ç†ä½†ä¸è¾“å‡ºæ—¥å¿—
    alignmentLines.value = [];
  }
};

// ä¿®æ”¹handleNodeDragStopï¼Œç¡®ä¿æ‹–åŠ¨ç»“æŸæ—¶å®Œå…¨å¯¹é½åˆ°æœ€è¿‘çš„å¯¹è±¡
const handleNodeDragStop = debounce((e: NodeDragEvent) => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor')) {
    // å¦‚æœç»„ä»¶å·²å¸è½½ï¼Œç›´æ¥è¿”å›
    return;
  }
  
  const { node } = e;
  
  try {
    // è·å–èŠ‚ç‚¹å½“å‰å°ºå¯¸
    const { width, height } = getNodeDimensions(node);
    
    // åœ¨åœæ­¢æ‹–åŠ¨æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥ç¡®ä¿èŠ‚ç‚¹ä¸æœ€è¿‘çš„å¯¹é½èŠ‚ç‚¹å®Œå…¨å¯¹é½
    const lines = alignmentLines.value;
    
    // è®°å½•åŸå§‹ä½ç½®
    let newPosition = { ...node.position };
    
    // å¦‚æœæœ‰å¯¹é½çº¿ï¼Œåº”ç”¨å¸é™?    if (lines.length > 0) {
      // è·å–å½“å‰èŠ‚ç‚¹ä¸­å¿ƒç‚?      const nodeCenter = nodeCenterMap.get(node.id);
      if (!nodeCenter) {
        return;
      }
      
      // ä»alignmentLinesä¸­æ‰¾åˆ°æ°´å¹³å’Œå‚ç›´çº?      const horizontalLine = lines.find(line => line.type === 'horizontal');
      const verticalLine = lines.find(line => line.type === 'vertical');
      
      if (horizontalLine || verticalLine) {
        // æŸ¥æ‰¾æ‰€æœ‰è¦å¯¹é½çš„èŠ‚ç‚¹ID
        let targetNodeIdY = '';
        let targetNodeIdX = '';
        
        // éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ‰¾åˆ°ä¸å¯¹é½çº¿åŒ¹é…çš„èŠ‚ç‚?        nodeCenterMap.forEach((center, id) => {
          if (id === node.id) return;
          
          // å¦‚æœæ°´å¹³å¯¹é½çº¿çš„ä½ç½®ä¸èŠ‚ç‚¹ä¸­å¿ƒç‚¹Yåæ ‡æ¥è¿‘ï¼Œæ ‡è®°ä¸ºç›®æ ‡èŠ‚ç‚¹
          if (horizontalLine && Math.abs(horizontalLine.position - center.y) < 0.1) {
            targetNodeIdY = id;
          }
          
          // å¦‚æœå‚ç›´å¯¹é½çº¿çš„ä½ç½®ä¸èŠ‚ç‚¹ä¸­å¿ƒç‚¹Xåæ ‡æ¥è¿‘ï¼Œæ ‡è®°ä¸ºç›®æ ‡èŠ‚ç‚¹
          if (verticalLine && Math.abs(verticalLine.position - center.x) < 0.1) {
            targetNodeIdX = id;
          }
        });
        
        // åº”ç”¨æ°´å¹³å¯¹é½ï¼ˆä¸­å¿ƒç‚¹Yå¯¹é½ï¼?        if (horizontalLine && targetNodeIdY) {
          // è·å–ç›®æ ‡èŠ‚ç‚¹
          const targetNode = getNodes.value.find(n => n.id === targetNodeIdY);
          if (targetNode) {
            // ç±»ä¼¼äºalignNodesæ–¹æ³•ï¼Œç›´æ¥è®¡ç®—ç²¾ç¡®ä½ç½?            const targetNodeDim = getNodeDimensions(targetNode);
            const targetCenterY = targetNode.position.y + targetNodeDim.height / 2;
            
            // ç›´æ¥è®¡ç®—éœ€è¦è®¾ç½®çš„Yä½ç½®ï¼Œä½¿å¾—èŠ‚ç‚¹ä¸­å¿ƒç‚¹ä¸ç›®æ ‡ä¸­å¿ƒç‚¹å¯¹é½
            newPosition.y = targetCenterY - height / 2;
          }
        }
        
        // åº”ç”¨å‚ç›´å¯¹é½ï¼ˆä¸­å¿ƒç‚¹Xå¯¹é½ï¼?        if (verticalLine && targetNodeIdX) {
          // è·å–ç›®æ ‡èŠ‚ç‚¹
          const targetNode = getNodes.value.find(n => n.id === targetNodeIdX);
          if (targetNode) {
            // ç±»ä¼¼äºalignNodesæ–¹æ³•ï¼Œç›´æ¥è®¡ç®—ç²¾ç¡®ä½ç½?            const targetNodeDim = getNodeDimensions(targetNode);
            const targetCenterX = targetNode.position.x + targetNodeDim.width / 2;
            
            // ç›´æ¥è®¡ç®—éœ€è¦è®¾ç½®çš„Xä½ç½®ï¼Œä½¿å¾—èŠ‚ç‚¹ä¸­å¿ƒç‚¹ä¸ç›®æ ‡ä¸­å¿ƒç‚¹å¯¹é½
            newPosition.x = targetCenterX - width / 2;
          }
        }
      }
    }
    
    // åˆ›å»ºæ–°çš„èŠ‚ç‚¹å¯¹è±¡ï¼Œè€Œä¸æ˜¯ä¿®æ”¹åŸå§‹å¯¹è±?    // è¿™æ˜¯å…³é”®æ­¥éª¤ï¼Œç¡®ä¿Vue Flowæ­£ç¡®æ›´æ–°èŠ‚ç‚¹ä½ç½®
    const updatedNodes = getNodes.value.map(n => 
      n.id === node.id ? { ...n, position: newPosition } : n
    );
    
    // æ›´æ–°çŠ¶æ€?    setNodes(updatedNodes);
    
    // æ›´æ–°æœ€ç»ˆä½ç½®çš„ä¸­å¿ƒç‚¹åæ ?    clearNodeDimensionsCache(node.id); // æ¸…é™¤ç¼“å­˜ç¡®ä¿å°ºå¯¸é‡æ–°è®¡ç®—
    
    // ä½¿ç”¨æ–°åˆ›å»ºçš„èŠ‚ç‚¹å¯¹è±¡æ›´æ–°ä¸­å¿ƒç‚?    const updatedNode = updatedNodes.find(n => n.id === node.id);
    if (updatedNode) {
      updateNodeCenter(updatedNode);
    }
  } catch (error) {
    // é”™è¯¯å¤„ç†ä½†ä¸è¾“å‡ºæ—¥å¿—
  } finally {
    // æ¸…é™¤å¯¹é½çº?    alignmentLines.value = [];
    
    // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?    if (document.querySelector('.flow-editor')) {
      saveToHistory(); // ä¿å­˜å†å²è®°å½•
    }
  }
}, 50);

const onSelectionChange = debounce(({ nodes }: { nodes: any[] }) => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor')) {
    return;
  }
  
  selectedNodes.value = nodes.map(node => node.id)
  nodes.forEach(node => {
    clearNodeDimensionsCache(node.id)
  })
}, 50)

// ä¿®æ”¹é”®ç›˜äº‹ä»¶å¤„ç†
const handleKeyboard = (event: KeyboardEvent) => {
  // å¦‚æœæ­£åœ¨ç¼–è¾‘æ–‡æœ¬ï¼Œä¸å¤„ç†å¿«æ·é”?  if (event.target instanceof HTMLTextAreaElement || event.target instanceof HTMLInputElement) {
    return
  }

  // å¤„ç†Escapeé”®ï¼Œé€€å‡ºèŠ‚ç‚¹ç¼–è¾‘çŠ¶æ€å’Œå–æ¶ˆé€‰æ‹©
  if (event.key === 'Escape') {
    // ä½¿ç”¨å…¬å…±å‡½æ•°å–æ¶ˆé€‰æ‹©å’Œç¼–è¾‘çŠ¶æ€?    clearSelectionAndEditingState()
    
    // é˜»æ­¢é»˜è®¤è¡Œä¸º
    event.preventDefault()
    return
  }

  // æ’¤é”€æ“ä½œ (Ctrl+Z)
  if (event.ctrlKey && event.key === 'z') {
    if (currentHistoryIndex.value > 0) {
      currentHistoryIndex.value--
      const previousState = history.value[currentHistoryIndex.value]
      
      const nodesWithCorrectSelection = previousState.nodes.map(node => ({
        ...node,
        selected: previousState.nodes[previousState.nodes.length - 1] && node.id === previousState.nodes[previousState.nodes.length - 1].id
      }));
      
      setNodes(nodesWithCorrectSelection)
      setEdges(previousState.edges)
      
      // æ›´æ–°é€‰ä¸­èŠ‚ç‚¹çš„ID
      selectedNodeId.value = previousState.nodes[previousState.nodes.length - 1] ? previousState.nodes[previousState.nodes.length - 1].id : null;
    }
  }

  // æ–¹å‘é”®å¤„ç†ï¼Œç§»åŠ¨é€‰ä¸­çš„èŠ‚ç‚?  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
    // è·å–æ‰€æœ‰é€‰ä¸­çš„èŠ‚ç‚?    const selectedNodes = getNodes.value.filter(node => node.selected);
    if (selectedNodes.length === 0) return;

    // ä¿å­˜ç§»åŠ¨å‰çš„çŠ¶æ€åˆ°å†å²è®°å½•
    saveToHistory();

    // æ ¹æ®æ–¹å‘é”®è®¡ç®—ç§»åŠ¨è·ç¦»ï¼ˆä»?åƒç´ ä¸ºå¢é‡ï¼‰
    let dx = 0;
    let dy = 0;
    
    switch(event.key) {
      case 'ArrowUp':
        dy = -2;
        break;
      case 'ArrowDown':
        dy = 2;
        break;
      case 'ArrowLeft':
        dx = -2;
        break;
      case 'ArrowRight':
        dx = 2;
        break;
    }
    
    // æ›´æ–°èŠ‚ç‚¹ä½ç½®
    const updatedNodes = getNodes.value.map(node => {
      if (!node.selected) return node;
      
      // è®¡ç®—æ–°ä½ç½®å¹¶ä¿ç•™ä¸€ä½å°æ•?      let newX = Number((node.position.x + dx).toFixed(1));
      let newY = Number((node.position.y + dy).toFixed(1));
      
      // ç¡®ä¿æ–°ä½ç½®çš„æ•´æ•°éƒ¨åˆ†æ˜?çš„å€æ•°
      if (Math.floor(newX) % 2 !== 0) {
        newX = Number((Math.floor(newX) + 1 + (newX - Math.floor(newX))).toFixed(1));
      }
      if (Math.floor(newY) % 2 !== 0) {
        newY = Number((Math.floor(newY) + 1 + (newY - Math.floor(newY))).toFixed(1));
      }
      
      return {
        ...node,
        position: {
          x: newX,
          y: newY
        }
      };
    });
    
    // åº”ç”¨æ›´æ–°åçš„èŠ‚ç‚¹ä½ç½®
    setNodes(updatedNodes);
    
    // æ›´æ–°èŠ‚ç‚¹ä¸­å¿ƒç‚¹åæ ?    updatedNodes.forEach(node => {
      if (node.selected) {
        clearNodeDimensionsCache(node.id);
        updateNodeCenter(node);
      }
    });
    
    // é˜»æ­¢äº‹ä»¶é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢é¡µé¢æ»šåŠ?    event.preventDefault();
    return;
  }

  // å¤åˆ¶å¿«æ·é”?(Ctrl+C)
  if (event.ctrlKey && event.key === 'c') {
    const selectedNodes = getNodes.value.filter(node => node.selected)
    if (selectedNodes.length > 0) {
      clipboard.value = selectedNodes.map(node => ({
        type: 'node',
        data: {
          id: node.id,
          type: node.type,
          position: { ...node.position },
          data: { 
            ...node.data,
            draggable: true,
            selectable: true,
            connectable: true
          }
        }
      }))
    }
  }

  // ç²˜è´´å¿«æ·é”?(Ctrl+V)
  if (event.ctrlKey && event.key === 'v') {
    if (clipboard.value.length > 0) {
      const offset = { x: 20, y: 20 }
      const newNodes = clipboard.value.map(item => {
        if (item.type === 'node') {
          const newId = `${item.data.type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
          return {
            id: newId,
            type: item.data.type,
            position: {
              x: item.data.position.x + offset.x,
              y: item.data.position.y + offset.y
            },
            data: { 
              ...item.data.data,
              draggable: true,
              selectable: true,
              connectable: true
            },
            draggable: true,
            selectable: true,
            connectable: true
          }
        }
        return null
      }).filter(Boolean) as FlowNode[]

      addNodes(newNodes)
      
      // å–æ¶ˆé€‰ä¸­å…¶ä»–èŠ‚ç‚¹ï¼Œåªé€‰ä¸­æ–°æ·»åŠ çš„èŠ‚ç‚¹
      const nodes = getNodes.value.map(node => ({
        ...node,
        selected: newNodes.some(n => n.id === node.id)
      }))
      setNodes(nodes)
      
      // æ›´æ–°é€‰ä¸­èŠ‚ç‚¹çš„IDï¼Œå¦‚æœåªç²˜è´´äº†ä¸€ä¸ªèŠ‚ç‚?      if (newNodes.length === 1) {
        selectedNodeId.value = newNodes[0].id;
      } else {
        selectedNodeId.value = null; // å¤šé€‰çŠ¶æ€?      }
      
      // åœ¨æ·»åŠ èŠ‚ç‚¹åä¿å­˜å†å²è®°å½•
      saveToHistory()
    }
  }
}

// ä¿®æ”¹åŒå‡»è¾¹çš„äº‹ä»¶å¤„ç†å™¨ï¼Œä½¿ç”¨æ¨¡æ€å¯¹è¯æ¡†
const onEdgeDoubleClick = (event: EdgeMouseEvent) => {
  event.event?.preventDefault()
  event.event?.stopPropagation()

  const { edge } = event
   
  // è®¾ç½®å½“å‰ç¼–è¾‘çš„è¾¹
  currentEditingEdge.value = edge
  
  // é¢„å¡«å……å·²æœ‰æ ‡ç­?  edgeLabelInput.value = typeof edge.label === 'string' ? edge.label : ''
  
  // æ˜¾ç¤ºæ¨¡æ€å¯¹è¯æ¡†
  showEdgeLabelDialog.value = true
  
  // åœ¨ä¸‹ä¸€ä¸?tick ä¸­èšç„¦è¾“å…¥æ¡†
  nextTick(() => {
    if (edgeLabelInputRef.value) {
      edgeLabelInputRef.value.focus()
      edgeLabelInputRef.value.select()
    }
  })
}

// æ·»åŠ ç¡®è®¤ç¼–è¾‘æ ‡ç­¾çš„æ–¹æ³?const confirmEdgeLabel = (labelValue: string) => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor') || !currentEditingEdge.value) {
    return;
  }
  
  // æ›´æ–°è¾¹çš„æ ‡ç­¾
  const updatedEdges = getEdges.value.map(e => {
    if (e.id === currentEditingEdge.value.id) {
      return { 
        ...e, 
        label: labelValue, 
        data: {
          ...e.data,
          label: labelValue
        }
      };
    }
    return e;
  });
  
  // ä¿å­˜å½“å‰çŠ¶æ€åˆ°å†å²è®°å½•
  saveToHistory();
  
  // æ›´æ–°è¾¹é›†å?  setEdges(updatedEdges);
  
  // å…³é—­å¯¹è¯æ¡†å¹¶æ¸…é™¤å½“å‰ç¼–è¾‘çš„è¾¹
  showEdgeLabelDialog.value = false;
  currentEditingEdge.value = null;
}

const cancelEdgeLabel = () => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶å­˜åœ?  if (!document.querySelector('.flow-editor')) {
    return;
  }
  
  showEdgeLabelDialog.value = false;
  currentEditingEdge.value = null;
}

// ç”Ÿå‘½å‘¨æœŸé’©å­
onMounted(() => {
  // æ³¨å†Œäº‹ä»¶ç›‘å¬å™?  registerEventListeners();
  
  // æ‰‹åŠ¨è·å–é€‰æ‹©æ¡†å…ƒç´?  const selectionBox = document.getElementById('selection-box');
  if (selectionBox) {
    selectionBoxRef.value = selectionBox;
  } else {
    // å¦‚æœæ‰¾ä¸åˆ°ï¼Œåˆ›å»ºä¸€ä¸?    const newSelectionBox = document.createElement('div');
    newSelectionBox.id = 'selection-box';
    newSelectionBox.className = 'selection-area';
    newSelectionBox.style.display = 'none';
    newSelectionBox.style.position = 'absolute';
    newSelectionBox.style.zIndex = '1000';
    
    // æ·»åŠ åˆ°ç”»å¸ƒå®¹å™¨ä¸­
    const canvasContainer = document.querySelector('.canvas-container');
    if (canvasContainer) {
      canvasContainer.appendChild(newSelectionBox);
      selectionBoxRef.value = newSelectionBox;
    }
  }
  
  // ç›´æ¥åœ¨Vue Flowçš„paneå…ƒç´ ä¸Šæ·»åŠ åŸç”Ÿäº‹ä»¶ç›‘å¬å™¨
  const paneElement = document.querySelector('.vue-flow__pane');
  if (paneElement) {
    // åŸç”Ÿé¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
    const paneMouseDownHandler = (e: MouseEvent) => {
      // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»æŒ‚è½½
      if (!componentMountedRef.value) return;
      
      // æ‰‹åŠ¨è°ƒç”¨æˆ‘ä»¬çš„å¤„ç†å‡½æ•?      onPaneMouseDown(e);
    };
    
    // åŸç”Ÿé¼ æ ‡ç§»åŠ¨äº‹ä»¶
    const paneMouseMoveHandler = (e: MouseEvent) => {
      // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»æŒ‚è½½
      if (!componentMountedRef.value) {
        // å¦‚æœç»„ä»¶å·²å¸è½½ï¼Œé‡ç½®çŠ¶æ€?        isSelecting.value = false;
        startPoint.value = null;
        currentPoint.value = null;
        return;
      }
      
      if (isSelecting.value) {
        // æ‰‹åŠ¨è°ƒç”¨æˆ‘ä»¬çš„å¤„ç†å‡½æ•?        onPaneMouseMove(e);
      }
    };
    
    // åŸç”Ÿé¼ æ ‡æ¾å¼€äº‹ä»¶
    const paneMouseUpHandler = (e: MouseEvent) => {
      // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»æŒ‚è½½
      if (!componentMountedRef.value) {
        // å¦‚æœç»„ä»¶å·²å¸è½½ï¼Œé‡ç½®çŠ¶æ€?        isSelecting.value = false;
        startPoint.value = null;
        currentPoint.value = null;
        return;
      }
      
      // æ‰‹åŠ¨è°ƒç”¨æˆ‘ä»¬çš„å¤„ç†å‡½æ•?      onPaneMouseUp(e);
    };
    
    // æ·»åŠ äº‹ä»¶ç›‘å¬å™?    paneElement.addEventListener('mousedown', paneMouseDownHandler as EventListener);
    document.addEventListener('mousemove', paneMouseMoveHandler as EventListener);
    document.addEventListener('mouseup', paneMouseUpHandler as EventListener);
    
    // å¸è½½æ—¶æ¸…é™¤äº‹ä»¶ç›‘å¬å™¨
    onUnmounted(() => {
      paneElement.removeEventListener('mousedown', paneMouseDownHandler as EventListener);
      document.removeEventListener('mousemove', paneMouseMoveHandler as EventListener);
      document.removeEventListener('mouseup', paneMouseUpHandler as EventListener);
    });
  }
});

// å¤„ç†é”®ç›˜äº‹ä»¶
const handleKeyDown = (event: KeyboardEvent) => {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»æŒ‚è½½
  if (!componentMountedRef.value) return;
  
  // å¦‚æœæ¨¡æ€å¯¹è¯æ¡†æ‰“å¼€ï¼Œä¸å¤„ç†é”®ç›˜äº‹ä»¶
  if (showEdgeLabelDialog.value) {
    return;
  }
  
  // åˆ é™¤é”®å¤„ç?  if (event.key === 'Delete' || event.key === 'Backspace') {
    // è·å–æ‰€æœ‰é€‰ä¸­çš„èŠ‚ç‚?    const selectedNodes = getNodes.value.filter(node => node.selected);
    if (selectedNodes.length > 0) {
      // å…ˆä¿å­˜å½“å‰çŠ¶æ€?      saveToHistory();
      // åˆ é™¤æ‰€æœ‰é€‰ä¸­çš„èŠ‚ç‚?      removeNodes(selectedNodes.map(node => node.id));
      selectedNodeId.value = null;
    }
    
    // è·å–æ‰€æœ‰é€‰ä¸­çš„è¾¹
    const selectedEdges = getEdges.value.filter(edge => edge.selected);
    if (selectedEdges.length > 0) {
      // å…ˆä¿å­˜å½“å‰çŠ¶æ€?      saveToHistory();
      // åˆ é™¤æ‰€æœ‰é€‰ä¸­çš„è¾¹
      removeEdges(selectedEdges.map(edge => edge.id));
      selectedEdgeId.value = null;
    }
  }

  handleKeyboard(event);
};

// å¤„ç†è°ƒæ•´å¤§å°å¼€å§‹äº‹ä»?const handleResizeStart = (event: Event) => {
  isResizing.value = true;
  // åœ¨è°ƒæ•´å¤§å°æœŸé—´ä¸éœ€è¦ç‰¹æ®Šå¤„ç†é”®ç›˜äº‹ä»?};

// å¤„ç†è°ƒæ•´å¤§å°ç»“æŸäº‹ä»¶
const handleResizeEnd = (event: Event) => {
  isResizing.value = false;
  resizeJustEnded.value = true;
  
  // æ¸…é™¤ä»»ä½•å¯èƒ½å­˜åœ¨çš„å…ˆå‰çš„å®šæ—¶å™?  if (resizeEndTimeoutRef.value) {
    clearTimeout(resizeEndTimeoutRef.value);
    resizeEndTimeoutRef.value = null;
  }
  
  // åœ¨ç»“æŸåç•¥å¾®å»¶è¿Ÿé‡æ–°ç”ŸæˆèŠ‚ç‚¹ä¸­å¿ƒç‚¹ï¼Œç¡®ä¿è°ƒæ•´å°ºå¯¸æ“ä½œå·²ç»å®Œå…¨åº”ç”¨
  resizeEndTimeoutRef.value = setTimeout(() => {
    // å†æ¬¡æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»æŒ‚è½½
    if (!componentMountedRef.value) {
      return;
    }
    
    // å¯ä»¥åœ¨è¿™é‡Œè·å–èŠ‚ç‚¹çš„æœ€æ–°å°ºå¯?    try {
      const nodeId = (event as CustomEvent).detail?.nodeId;
      if (nodeId) {
        const node = findNode(nodeId);
      }
    } catch (error) {
      console.error('[FlowEditor] å¤„ç†resize-endäº‹ä»¶æ—¶å‡ºé”?', error);
    }
    
    resizeJustEnded.value = false;
    
    // é‡ç½®å¼•ç”¨
    resizeEndTimeoutRef.value = null;
  }, 100);
  
  // ç¡®ä¿ä¸è¿”å›å€¼ï¼Œé¿å…å¼‚æ­¥å“åº”é—®é¢˜
  return undefined;
};

// æ¸…é™¤äº‹ä»¶ç›‘å¬å™?const unregisterEventListeners = () => {
  window.removeEventListener('keydown', handleKeyDown);
  window.removeEventListener('resize-start', handleResizeStart);
  window.removeEventListener('resize-end', handleResizeEnd);
};

// æ³¨å†Œäº‹ä»¶ç›‘å¬å™?const registerEventListeners = () => {
  // é¿å…é‡å¤æ³¨å†Œ
  unregisterEventListeners();
  
  // æ³¨å†Œå…¨å±€äº‹ä»¶ç›‘å¬å™?  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('resize-start', handleResizeStart);
  window.addEventListener('resize-end', handleResizeEnd);
  
  // æ³¨å†ŒVue Flowäº‹ä»¶
  onConnect(onConnectHandler);
  registerNodeDragStop(handleNodeDragStop);
  registerEdgeClick(onEdgeClick);
};

// åœ¨ç»„ä»¶å¸è½½æ—¶æ¸…ç†
onUnmounted(() => {
  componentMountedRef.value = false;
  
  // æ¸…é™¤resize-endçš„timeout
  if (resizeEndTimeoutRef.value) {
    clearTimeout(resizeEndTimeoutRef.value);
    resizeEndTimeoutRef.value = null;
  }
  
  // æ¸…é™¤äº‹ä»¶ç›‘å¬å™?  unregisterEventListeners();
  
  // å…¶ä»–æ¸…ç†ä»£ç ...
});

// åˆå§‹åŒ–å†å²è®°å½?- åªæœ‰å½“ç”»å¸ƒä¸Šæœ‰å†…å®¹æ—¶æ‰ä¿å­˜åˆå§‹çŠ¶æ€?// åªæœ‰å½“ç”»å¸ƒä¸Šæœ‰èŠ‚ç‚¹æˆ–è¾¹æ—¶æ‰åˆå§‹åŒ–å†å²è®°å½•
if (getNodes.value.length > 0 || getEdges.value.length > 0) {
  saveToHistory();
} else {
  // å¦‚æœç”»å¸ƒä¸ºç©ºï¼Œåªåˆå§‹åŒ–ç´¢å¼•ï¼Œä¸ä¿å­˜çŠ¶æ€?  currentHistoryIndex.value = -1;
  history.value = [];
}

// åˆå§‹åŒ–æ‰€æœ‰èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹åæ ?initNodeCenters();

// ç›‘å¬èŠ‚ç‚¹å˜åŒ–ï¼Œä½¿ç”¨è¾ƒé•¿çš„é—´éš”
let nodeObserverInterval: number | undefined;
let isComponentMounted = true;
  
const nodeObserverCallback = () => {
  if (!isComponentMounted || !componentMountedRef.value) {
    // å¦‚æœç»„ä»¶å·²å¸è½½ï¼Œæ¸…é™¤å®šæ—¶å™?    if (nodeObserverInterval) {
      clearInterval(nodeObserverInterval);
      nodeObserverInterval = undefined;
    }
    return;
  }
    
  // è°ƒç”¨observeNodeså¹¶æ£€æŸ¥è¿”å›å€?  const shouldContinue = observeNodes();
    
  // å¦‚æœè¿”å›falseï¼Œè¡¨ç¤ºåº”è¯¥åœæ­¢è§‚å¯?  if (!shouldContinue && nodeObserverInterval) {
    clearInterval(nodeObserverInterval);
    nodeObserverInterval = undefined;
  }
};
  
nodeObserverInterval = window.setInterval(nodeObserverCallback, 1500);
  
  // åœ¨å¸è½½ç»„ä»¶å‰æ¸…ç†æ‰€æœ‰çš„è®¡æ—¶å™¨å’Œç›‘å¬å™?  onUnmounted(() => {
    // è®¾ç½®æ ‡å¿—ï¼Œè¡¨ç¤ºç»„ä»¶å·²å¸è½½
    isComponentMounted = false;
    
    // å–æ¶ˆæ‰€æœ‰çš„é—´éš”è°ƒç”¨
    if (nodeObserverInterval) {
      clearInterval(nodeObserverInterval);
      nodeObserverInterval = undefined;
    }
    
    window.removeEventListener('keydown', handleKeyDown);
    window.removeEventListener('resize-start', handleResizeStart);
    window.removeEventListener('resize-end', handleResizeEnd);
    
    // å–æ¶ˆæ‰€æœ‰çš„é˜²æŠ–å‡½æ•°
    if (typeof handleNodeDragStop.cancel === 'function') {
      handleNodeDragStop.cancel();
    }
    
    if (typeof onSelectionChange.cancel === 'function') {
      onSelectionChange.cancel();
    }
    
    if (typeof initNodeCenters.cancel === 'function') {
      initNodeCenters.cancel();
    }
    
    // æ¸…é™¤æ‰€æœ‰é€‰æ‹©çŠ¶æ€å’Œç¼–è¾‘çŠ¶æ€ï¼Œé¿å…çŠ¶æ€æ®‹ç•?    clearSelectionAndEditingState();
    
    // æ¸…é™¤å¯¹é½çº?    alignmentLines.value = [];
    
    // æ¸…é™¤å½“å‰ç‚¹å’Œèµ·å§‹ç‚?    currentPoint.value = null;
    startPoint.value = null;
    isSelecting.value = false;
    
    // å¦‚æœé€‰æ‹©æ¡†è¿˜å­˜åœ¨ï¼Œæ¸…é™¤å®ƒ
    if (selectionBoxRef.value) {
      selectionBoxRef.value.style.display = 'none';
    }
    
    // æ¸…é™¤æ‰€æœ‰ç¼“å­?    nodeDimensionsCache.clear();
    nodeCenterMap.clear();
  });

// å±‚çº§æ’åˆ—æ–¹æ³•
const arrangeLayers = (action: 'top' | 'bottom' | 'up' | 'down') => {
  // è·å–é€‰ä¸­çš„èŠ‚ç‚?  const selectedNodeList = getNodes.value.filter(node => node.selected)
  if (selectedNodeList.length === 0) return
  
  // è·å–æ‰€æœ‰èŠ‚ç‚¹ï¼ŒæŒ‰zIndexæ’åºï¼Œé»˜è®¤æ²¡æœ‰zIndexçš„èŠ‚ç‚¹è§†ä¸?
  const allNodes = getNodes.value.map(node => ({
    ...node,
    zIndex: node.zIndex !== undefined ? node.zIndex : 0
  }))
  
  // æ‰¾å‡ºå½“å‰æœ€å¤§å’Œæœ€å°zIndex
  const maxZIndex = Math.max(...allNodes.map(node => node.zIndex || 0))
  const minZIndex = Math.min(...allNodes.map(node => node.zIndex || 0))
  
  // æ ¹æ®ä¸åŒçš„æ“ä½œæ›´æ–°èŠ‚ç‚¹çš„zIndex
  let updatedNodes: FlowNode[] = []
  
  switch (action) {
    case 'top': // ç½®äºé¡¶å±‚
      updatedNodes = getNodes.value.map(node => ({
        ...node,
        zIndex: node.selected ? maxZIndex + 1 : node.zIndex
      }))
      break
    
    case 'bottom': // ç½®äºåº•å±‚
      updatedNodes = getNodes.value.map(node => ({
        ...node,
        zIndex: node.selected ? minZIndex - 1 : node.zIndex
      }))
      break
    
    case 'up': // ä¸Šç§»ä¸€å±?      updatedNodes = getNodes.value.map(node => {
        if (!node.selected) return node
        
        const currentZIndex = node.zIndex !== undefined ? node.zIndex : 0
        return {
          ...node,
          zIndex: currentZIndex + 1
        }
      })
      break
    
    case 'down': // ä¸‹ç§»ä¸€å±?      updatedNodes = getNodes.value.map(node => {
        if (!node.selected) return node
        
        const currentZIndex = node.zIndex !== undefined ? node.zIndex : 0
        return {
          ...node,
          zIndex: currentZIndex - 1
        }
      })
      break
  }
  
  // æ›´æ–°èŠ‚ç‚¹
  setNodes(updatedNodes as any)
  
  // ä¿å­˜å†å²è®°å½•
  saveToHistory()
}

// å¤„ç†ç”»å¸ƒé¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
const onPaneMouseDown = (event: MouseEvent) => {
  // åªå¤„ç†é¼ æ ‡å·¦é”®äº‹ä»¶ï¼Œå¿½ç•¥å³é”®
  if (event.button !== 0) return;
  
  // æ£€æŸ¥ç‚¹å‡»çš„ç›®æ ‡æ˜¯å¦æ˜¯ç”»å¸?  const target = event.target as HTMLElement;
  
  // åªæœ‰åœ¨ç‚¹å‡»ç”»å¸ƒç©ºç™½åŒºåŸŸæˆ–è€…ç‰¹å®šæƒ…å†µä¸‹æ‰è§¦å‘æ¡†é€?  const isCanvas = target.classList.contains('vue-flow__pane') || 
                 target.classList.contains('vue-flow__container');
  
  if (!isCanvas) {
    return;
  }
  
  // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢è§¦å‘å…¶ä»–äº‹ä»?  event.preventDefault();
  event.stopPropagation();
  
  // è·å–ç”»å¸ƒå…ƒç´ çš„è¾¹ç•ŒçŸ©å½?  const vueFlowElement = document.querySelector('.vue-flow');
  
  if (vueFlowElement) {
    const rect = vueFlowElement.getBoundingClientRect();
    
    // è®¡ç®—ç›¸å¯¹äºç”»å¸ƒçš„ç‚¹å‡»ä½ç½®
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    // è®¾ç½®èµ·å§‹ç‚?    startPoint.value = { x, y };
    
    // è®¾ç½®ä¸ºé€‰æ‹©çŠ¶æ€?    isSelecting.value = true;
    
    // æ˜¾ç¤ºé€‰æ‹©æ¡?    const selectionBox = document.getElementById('selection-box');
    if (selectionBox) {
      selectionBoxRef.value = selectionBox;
      selectionBox.style.display = 'block';
      selectionBox.style.position = 'absolute';
      selectionBox.style.left = `${x}px`;
      selectionBox.style.top = `${y}px`;
      selectionBox.style.width = '0px';
      selectionBox.style.height = '0px';
      selectionBox.style.border = '2px dashed cornflowerblue';
      selectionBox.style.backgroundColor = 'rgba(100, 149, 237, 0.1)';
      selectionBox.style.zIndex = '1000';
      selectionBox.style.pointerEvents = 'none';
    }
    
    // è®¾ç½®å½“å‰ç‚¹ä¸ºèµ·å§‹ç‚?    currentPoint.value = { x, y };
  }
}

// å¤„ç†ç”»å¸ƒé¼ æ ‡ç§»åŠ¨äº‹ä»¶
const onPaneMouseMove = (event: MouseEvent) => {
  // å¦‚æœæ²¡æœ‰è¿›å…¥é€‰æ‹©çŠ¶æ€ï¼Œä¸å¤„ç?  if (!isSelecting.value || !startPoint.value) {
    return;
  }
  
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶æŒ‚è½?  if (!document.querySelector('.flow-editor')) {
    // å¦‚æœç»„ä»¶å·²å¸è½½ï¼Œé‡ç½®çŠ¶æ€å¹¶è¿”å›
    isSelecting.value = false;
    startPoint.value = null;
    currentPoint.value = null;
    return;
  }
  
  // é˜»æ­¢é»˜è®¤çš„ç”»å¸ƒæ‹–æ‹½è¡Œä¸?  event.preventDefault();
  event.stopPropagation();
  
  // è·å–ç”»å¸ƒå…ƒç´ çš„è¾¹ç•ŒçŸ©å½?  const canvasContainer = document.querySelector('.canvas-container');
  const vueFlowElement = document.querySelector('.vue-flow');
  
  const canvas = canvasContainer || vueFlowElement;
  
  if (canvas) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    currentPoint.value = { x, y };
    
    // è®¡ç®—é€‰æ‹©æ¡†çš„ä½ç½®å’Œå°ºå¯?    const left = Math.min(startPoint.value.x, x);
    const top = Math.min(startPoint.value.y, y);
    const width = Math.abs(x - startPoint.value.x);
    const height = Math.abs(y - startPoint.value.y);
    
    // æ›´æ–°é€‰æ‹©æ¡†çš„ä½ç½®å’Œå°ºå¯?    if (selectionBoxRef.value) {
      selectionBoxRef.value.style.left = `${left}px`;
      selectionBoxRef.value.style.top = `${top}px`;
      selectionBoxRef.value.style.width = `${width}px`;
      selectionBoxRef.value.style.height = `${height}px`;
    }
  }
};

// å¤„ç†ç”»å¸ƒé¼ æ ‡é‡Šæ”¾äº‹ä»¶
const onPaneMouseUp = (event: MouseEvent) => {
  // å¦‚æœæ²¡æœ‰è¿›å…¥é€‰æ‹©çŠ¶æ€ï¼Œä¸å¤„ç?  if (!isSelecting.value || !startPoint.value || !currentPoint.value) {
    return;
  }
  
  // é˜»æ­¢é»˜è®¤è¡Œä¸º
  event.preventDefault();
  event.stopPropagation();
  
  // è®¡ç®—é€‰æ‹©æ¡†çš„ä½ç½®å’Œå°ºå¯¸ï¼ˆç›¸å¯¹äºç”»å¸ƒè§†å£ï¼‰
  const left = Math.min(startPoint.value.x, currentPoint.value.x);
  const top = Math.min(startPoint.value.y, currentPoint.value.y);
  const width = Math.abs(currentPoint.value.x - startPoint.value.x);
  const height = Math.abs(currentPoint.value.y - startPoint.value.y);
  
  // è·å–ç”»å¸ƒå˜æ¢ä¿¡æ¯
  const { zoom, x: panX, y: panY } = getTransform();
  
  // é‡ç½®DOMé€‰æ‹©æ¡†çŠ¶æ€?  if (selectionBoxRef.value) {
    selectionBoxRef.value.style.display = 'none';
  }
  
  // å¦‚æœé€‰æ‹©æ¡†å¤ªå°ï¼Œè§†ä¸ºç‚¹å‡»äº‹ä»¶ï¼Œä¸æ‰§è¡Œé€‰æ‹©æ“ä½œ
  if (width < 5 && height < 5) {
    // é‡ç½®çŠ¶æ€?    isSelecting.value = false;
    startPoint.value = null;
    currentPoint.value = null;
    return;
  }
  
  // å°†è§†å£åæ ‡è½¬æ¢ä¸ºæµç¨‹å›¾å®é™…åæ ?  const flowSelectionRect = {
    left: (left - panX) / zoom,
    top: (top - panY) / zoom,
    right: (left + width - panX) / zoom,
    bottom: (top + height - panY) / zoom
  };
  
  // è·å–åœ¨é€‰æ‹©æ¡†å†…çš„èŠ‚ç‚?  const selectedNodeIds = getNodes.value
    .filter(node => {
      // è·å–èŠ‚ç‚¹çš„ä½ç½?      const nodePos = node.position;
      
      // è·å–èŠ‚ç‚¹å°ºå¯¸
      let nodeWidth = 0;
      let nodeHeight = 0;
      
      // ä»DOMè·å–çœŸå®èŠ‚ç‚¹å°ºå¯¸
      const nodeEl = document.querySelector(`[data-id="${node.id}"]`);
      if (nodeEl) {
        const innerNode = nodeEl.querySelector('.rounded-rect-node, .condition-node, .circle-node, .start-end-node, .text-label-node, .line-node, .svg-icon-node');
        if (innerNode) {
          const rect = innerNode.getBoundingClientRect();
          nodeWidth = rect.width / zoom;
          nodeHeight = rect.height / zoom;
        } else {
          const rect = nodeEl.getBoundingClientRect();
          nodeWidth = rect.width / zoom;
          nodeHeight = rect.height / zoom;
        }
      }
      
      // å¦‚æœDOMæ–¹æ³•å¤±è´¥ï¼Œä»èŠ‚ç‚¹æ•°æ®è·å–å°ºå¯¸
      if (nodeWidth <= 0 || nodeHeight <= 0) {
        // ä»dimensionså±æ€§è·å?        if (node.dimensions) {
          nodeWidth = node.dimensions.width;
          nodeHeight = node.dimensions.height;
        } 
        // ä»styleå±æ€§è·å?        else if (node.data?.style) {
          const style = node.data.style;
          if (typeof style.width === 'string') {
            const match = style.width.match(/(\d+)/);
            if (match) nodeWidth = parseInt(match[1], 10);
          } else if (typeof style.width === 'number') {
            nodeWidth = style.width;
          }
          
          if (typeof style.height === 'string') {
            const match = style.height.match(/(\d+)/);
            if (match) nodeHeight = parseInt(match[1], 10);
          } else if (typeof style.height === 'number') {
            nodeHeight = style.height;
          }
        }
        
        // ä½¿ç”¨èŠ‚ç‚¹ç±»å‹ç‰¹å®šçš„é»˜è®¤å°ºå¯?        if (nodeWidth <= 0) {
          nodeWidth = node.type === 'circle' ? 38 : 
                     node.type === 'svgIcon' ? 24 : 
                     node.type === 'line' ? 120 : 100;
        }
        if (nodeHeight <= 0) {
          nodeHeight = node.type === 'circle' ? 38 : 
                      node.type === 'condition' ? 60 : 
                      node.type === 'svgIcon' ? 24 :
                      node.type === 'line' ? 1 : 38;
        }
      }
      
      // è®¡ç®—èŠ‚ç‚¹è¾¹ç•Œæ¡?      const nodeRight = nodePos.x + nodeWidth;
      const nodeBottom = nodePos.y + nodeHeight;
      
      // ä½¿ç”¨ç›¸äº¤é€»è¾‘ï¼ŒèŠ‚ç‚¹åªè¦å’Œé€‰æ‹©æ¡†æœ‰äº¤é›†å°±é€‰ä¸­
      const isIntersecting = !(
        nodeRight < flowSelectionRect.left || 
        nodePos.x > flowSelectionRect.right || 
        nodeBottom < flowSelectionRect.top || 
        nodePos.y > flowSelectionRect.bottom
      );
      
      return isIntersecting;
    })
    .map(node => node.id);
  
  // ä¿å­˜é€‰ä¸­èŠ‚ç‚¹çš„IDåˆ°selectedNodesViaAreaSelection
  selectedNodesViaAreaSelection.value = selectedNodeIds;
  
  // æ›´æ–° selectedNodes å¼•ç”¨
  selectedNodes.value = selectedNodeIds;
  
  // å°†æ‰€æœ‰èŠ‚ç‚¹è®¾ç½®ä¸ºéé€‰ä¸­ï¼Œå†å°†æ¡†é€‰ä¸­çš„èŠ‚ç‚¹è®¾ç½®ä¸ºé€‰ä¸­
  const nodes = getNodes.value;
  const updatedNodes = nodes.map(node => ({
    ...node,
    selected: selectedNodeIds.includes(node.id)
  }));
  
  // ä½¿ç”¨setNodesæ›´æ–°èŠ‚ç‚¹çŠ¶æ€?  setNodes(updatedNodes as any);
  
  // æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡onSelectionChangeï¼Œç¡®ä¿å®ƒæ¥æ”¶åˆ°æ­£ç¡®çš„é€‰ä¸­èŠ‚ç‚¹
  const selectedNodesObjects = updatedNodes.filter(n => selectedNodeIds.includes(n.id));
  onSelectionChange({ nodes: selectedNodesObjects });
  
  // æ·»åŠ å»¶è¿Ÿæ£€æŸ¥æœ€ç»ˆé€‰ä¸­çŠ¶æ€?  setTimeout(() => {
    // éªŒè¯æ‰€æœ‰éœ€è¦é€‰ä¸­çš„èŠ‚ç‚¹æ˜¯å¦ç¡®å®è¢«é€‰ä¸­
    const finalSelection = getNodes.value
      .filter(node => node.selected)
      .map(node => node.id);
    
    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰åº”é€‰ä¸­çš„èŠ‚ç‚¹éƒ½è¢«é€‰ä¸­
    const allSelected = selectedNodeIds.every(id => 
      getNodes.value.find(n => n.id === id)?.selected
    );
    
    // å¦‚æœä»æœ‰é—®é¢˜ï¼Œå°è¯•æœ€åçš„è§£å†³æ–¹æ³•
    if (!allSelected) {
      const finalNodes = getNodes.value.map(node => ({
        ...node,
        selected: selectedNodeIds.includes(node.id)
      }));
      
      // å†æ¬¡åº”ç”¨æ›´æ–°
      setNodes(finalNodes as any);
    }
  }, 100);
  
  // é‡ç½®æ¡†é€‰çŠ¶æ€?  isSelecting.value = false;
  startPoint.value = null;
  currentPoint.value = null;
  
  // ä¿å­˜å†å²è®°å½•
  saveToHistory();
}

// è·å–æ—¶é—´æˆ?const getTimestamp = () => {
  const now = new Date()
  return `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`
}

/**
 * å¤„ç†èŠ‚ç‚¹æ•°æ®ï¼Œæ ‡å‡†åŒ–å±æ€§å’Œå€? * @param nodes åŸå§‹èŠ‚ç‚¹æ•°æ®æ•°ç»„
 * @returns å¤„ç†åçš„èŠ‚ç‚¹æ•°æ®æ•°ç»„
 */
const processNodeData = (nodes: any[]): any[] => {
  return nodes.map((node: any) => {
    // ç›´æ¥ä½¿ç”¨åŸå§‹ä½ç½®ï¼Œä¸è¿›è¡Œä»»ä½•ä¿®æ”¹
    const position = {
      x: node.position.x,
      y: node.position.y
    }

    // æå–èŠ‚ç‚¹å®½åº¦å’Œé«˜åº¦å¹¶ç¡®ä¿æ˜¯æ•°å­?    let width: number = 100; // é»˜è®¤å®½åº¦
    let height: number = 38; // é»˜è®¤é«˜åº¦
    
    // ä»node.widthè·å–å®½åº¦
    if (typeof node.width === 'number') {
      width = node.width;
    }
    // ä»æ ·å¼è·å–å®½åº?    else if (node.data?.style?.width && typeof node.data.style.width === 'string') {
      const parsedWidth = parseInt(node.data.style.width);
      if (!isNaN(parsedWidth)) {
        width = parsedWidth;
      }
    }
    
    // ä»node.heightè·å–é«˜åº¦
    if (typeof node.height === 'number') {
      height = node.height;
    }
    // ä»æ ·å¼è·å–é«˜åº?    else if (node.data?.style?.height && typeof node.data.style.height === 'string') {
      const parsedHeight = parseInt(node.data.style.height);
      if (!isNaN(parsedHeight)) {
        height = parsedHeight;
      }
    }

    return {
      ...node,
      // ä½¿ç”¨åŸå§‹ä½ç½®
      position,
      // ä¿å­˜å®½åº¦å’Œé«˜åº¦å±æ€?      width,
      height,
      data: {
        ...node.data,
        label: node.data?.label || '',
        fontSize: Number(node.data?.fontSize) || 14,
        color: node.data?.color || '#000000',
        style: {
          ...(node.data?.style || {}),
          width: `${width}px`,
          height: `${height}px`
        }
      },
      selected: false
    }
  });
}

/**
 * å¤„ç†è¾¹æ•°æ®ï¼Œæ ‡å‡†åŒ–å±æ€§å’Œå€? * @param edges åŸå§‹è¾¹æ•°æ®æ•°ç»? * @returns å¤„ç†åçš„è¾¹æ•°æ®æ•°ç»? */
const processEdgeData = (edges: any[]): any[] => {
  return edges.map((edge: any) => ({
    ...edge,  // ä¿ç•™æ‰€æœ‰åŸå§‹å±æ€?    id: edge.id,
    source: edge.source,
    target: edge.target,
    sourceHandle: edge.sourceHandle,  // ç¡®ä¿ä½¿ç”¨åŸå§‹æºé”šç‚?    targetHandle: edge.targetHandle,  // ç¡®ä¿ä½¿ç”¨åŸå§‹ç›®æ ‡é”šç‚¹
    type: edge.type || 'smoothstep',  // ä½¿ç”¨åŸå§‹è¾¹ç±»å‹ï¼Œé»˜è®¤ä¸ºsmoothstep
    style: {
      ...(typeof edge.style === 'object' ? edge.style : {}),
      strokeWidth: typeof edge.style === 'object' ? edge.style.strokeWidth || 1 : 1,
      stroke: typeof edge.style === 'object' ? edge.style.stroke || '#555555' : '#555555'
    },
    markerEnd: edge.markerEnd,
    markerStart: edge.markerStart,
    data: edge.data,
    selected: false
  }));
}

/**
 * å¯¼å‡ºæµç¨‹å›¾æ•°æ®ä¸ºJSONå¯¹è±¡
 * @returns å½“å‰æµç¨‹å›¾çš„æ•°æ®å¯¹è±¡
 */
const getFlowData = () => {
  // è·å–èŠ‚ç‚¹å’Œè¾¹çš„æ•°æ?  const nodes = getNodes.value.map((node) => {
    // ç›´æ¥ä½¿ç”¨åŸå§‹ä½ç½®ï¼Œä¸ä¿®æ”¹åæ ‡
    const position = {
      x: node.position.x,
      y: node.position.y
    }

    // æå–èŠ‚ç‚¹çš„å®½åº¦å’Œé«˜åº¦
    let width: number = 100; // é»˜è®¤å®½åº¦
    let height: number = 38; // é»˜è®¤é«˜åº¦
    
    // å°è¯•ä»DOMè·å–èŠ‚ç‚¹å°ºå¯¸
    const nodeElement = document.querySelector(`[data-id="${node.id}"]`);
    if (nodeElement) {
      const rect = nodeElement.getBoundingClientRect();
      width = Math.round(rect.width);
      height = Math.round(rect.height);
    } else {
      // ä»æ ·å¼è·å–å®½åº¦å’Œé«˜åº¦
      if (node.data?.style?.width && typeof node.data.style.width === 'string') {
        const parsedWidth = parseInt(node.data.style.width);
        if (!isNaN(parsedWidth)) {
          width = parsedWidth;
        }
      }
      
      if (node.data?.style?.height && typeof node.data.style.height === 'string') {
        const parsedHeight = parseInt(node.data.style.height);
        if (!isNaN(parsedHeight)) {
          height = parsedHeight;
        }
      }
    }

    return {
      ...node,
      position,
      // ä¿å­˜èŠ‚ç‚¹å°ºå¯¸ä¿¡æ¯
      width,
      height,
      data: {
        ...node.data,
        label: node.data?.label || '',
        fontSize: node.data?.fontSize || 14,
        color: node.data?.color || '#000000',
        style: {
          ...(node.data?.style || {}),
          width: `${width}px`,
          height: `${height}px`
        }
      },
      selected: false // é‡ç½®é€‰ä¸­çŠ¶æ€?    }
  })

  // å®Œæ•´ä¿å­˜è¾¹çš„æ‰€æœ‰å±æ€§ï¼Œç‰¹åˆ«æ˜¯é”šç‚¹ä¿¡æ?  const edges = getEdges.value.map((edge) => ({
    ...edge,  // ä¿ç•™æ‰€æœ‰åŸå§‹å±æ€?    id: edge.id,
    source: edge.source,
    target: edge.target,
    sourceHandle: edge.sourceHandle,  // æ˜ç¡®ä¿å­˜æºé”šç‚?    targetHandle: edge.targetHandle,  // æ˜ç¡®ä¿å­˜ç›®æ ‡é”šç‚¹
    type: edge.type,  // ä¿ç•™åŸå§‹è¾¹ç±»å‹ï¼Œä¸è®¾ç½®é»˜è®¤å€?    style: {
      ...(typeof edge.style === 'object' ? edge.style : {}),
      strokeWidth: typeof edge.style === 'object' ? edge.style.strokeWidth || 1 : 1,
      stroke: typeof edge.style === 'object' ? edge.style.stroke || '#555555' : '#555555'
    },
    markerEnd: edge.markerEnd,
    markerStart: edge.markerStart,
    data: edge.data,
    selected: false
  }))

  return {
    nodes,
    edges,
    metadata: {
      version: '1.0.0',
      timestamp: new Date().toISOString(),
      title: `æµç¨‹å›¾_${getTimestamp()}`
    }
  }
}

/**
 * å°†æµç¨‹å›¾æ•°æ®å¯¼å‡ºä¸ºJSONæ–‡ä»¶å¹¶ä¸‹è½? */
const exportFlowData = () => {
  try {
    const flowData = getFlowData()
    
    const jsonStr = JSON.stringify(flowData, null, 2)
    const blob = new Blob([jsonStr], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = `flowchart_${getTimestamp()}.json`
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
  } catch (error) {
    console.error('å¯¼å‡ºæ•°æ®å¤±è´¥:', error)
    alert('å¯¼å‡ºæ•°æ®å¤±è´¥ï¼? + (error instanceof Error ? error.message : String(error)))
  }
}

/**
 * è·å–æµç¨‹å›¾çš„æ•°æ®URL
 * æ­¤å‡½æ•°ä¼šè®¡ç®—æµç¨‹å›¾ä¸Šæ‰€æœ‰å¯è§å…ƒç´ çš„è¾¹ç•Œï¼Œå¹¶å¯¼å‡ºä¸ºå›¾ç‰? * @param format è¾“å‡ºæ ¼å¼ï¼?jpg'æˆ?png'
 * @param download æ˜¯å¦è‡ªåŠ¨ä¸‹è½½å›¾ç‰‡
 * @returns Promise<string | null> è¿”å›ç”Ÿæˆçš„dataUrl
 */
const getDataUrl = async (format: 'jpg' | 'png' = 'jpg', download: boolean = false): Promise<string | null> => {
  // å£°æ˜å˜é‡ï¼Œç¡®ä¿å®ƒä»¬åœ¨finallyå—ä¸­å¯ç”¨
  let vueFlowElement: HTMLElement | null = null;
  let originalTransform = { x: 0, y: 0, zoom: 1 };
  let originalNodes: any[] = [];
  let originalEdges: any[] = [];
  let originalWidth = '';
  let originalHeight = '';
  let originalViewportOverflow = '';
  
  try {
    vueFlowElement = document.querySelector('.vue-flow') as HTMLElement
    if (!vueFlowElement) {
      console.error('æ‰¾ä¸åˆ°æµç¨‹å›¾å…ƒç´ ')
      return null
    }

    // æ·»åŠ ä¸€ä¸ªç±»æ¥é˜²æ­¢UIæŠ–åŠ¨
    document.body.classList.add('exporting-image')
    
    // ä¿å­˜åŸå§‹çŠ¶æ€?    originalTransform = { ...getTransform() }
    originalNodes = getNodes.value.map(node => ({ ...node }))
    originalEdges = getEdges.value.map(edge => ({ ...edge }))
    originalWidth = vueFlowElement.style.width
    originalHeight = vueFlowElement.style.height
    originalViewportOverflow = vueFlowElement.style.overflow

    // å°†èŠ‚ç‚¹å’Œè¾¹éƒ½è®¾ä¸ºéé€‰ä¸­çŠ¶æ€?    setNodes(getNodes.value.map(node => ({ ...node, selected: false })) as any)
    setEdges(getEdges.value.map(edge => ({ ...edge, selected: false })))

    // è®¡ç®—æµç¨‹å›¾å®é™…å†…å®¹çš„è¾¹ç•Œ - ä½¿ç”¨æ›´ç›´æ¥çš„æ–¹æ³•
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity
    
    try {
      // æ”¶é›†æ‰€æœ‰å¯èƒ½çš„å…ƒç´ ï¼šèŠ‚ç‚¹ã€è¾¹è·¯å¾„ã€æ ‡ç­¾ã€è¿æ¥ç‚¹ç­?      const allElements = [
        ...Array.from(document.querySelectorAll('.vue-flow__node')),
        ...Array.from(document.querySelectorAll('.vue-flow__edge')),
        ...Array.from(document.querySelectorAll('.vue-flow__edge-textwrapper')),
        ...Array.from(document.querySelectorAll('.vue-flow__connection-path')),
        ...Array.from(document.querySelectorAll('.vue-flow__handle')),
        ...Array.from(document.querySelectorAll('.vue-flow__connectionline')),
        ...Array.from(document.querySelectorAll('.vue-flow__edge-interaction')),
        ...Array.from(document.querySelectorAll('.vue-flow__edge-path-selector'))
      ]
      
      // è®¡ç®—è§†å£åæ ‡åˆ°ç”»å¸ƒåæ ‡çš„è½¬æ¢æ¯”ä¾‹
      const currentZoom = getTransform().zoom || 1
      const zoomInv = 1 / currentZoom
      const panX = getTransform().x || 0
      const panY = getTransform().y || 0
      const vueFlowRect = vueFlowElement.getBoundingClientRect()
      
      // ä¸´æ—¶æ•°æ®ï¼Œç”¨äºè°ƒè¯?      const elementDebugData = []
      
      // è·å–æ‰€æœ‰å…ƒç´ çš„è¾¹ç•Œæ¡†å¹¶è½¬æ¢ä¸ºç”»å¸ƒåæ ?      allElements.forEach(element => {
        const rect = element.getBoundingClientRect()
        if (rect && rect.width > 0 && rect.height > 0) {
          // ç›¸å¯¹äºè§†å£çš„åæ ‡
          const relX = rect.left - vueFlowRect.left
          const relY = rect.top - vueFlowRect.top
          
          // è½¬æ¢ä¸ºç”»å¸ƒåæ ?          const canvasX = relX * zoomInv - panX * zoomInv
          const canvasY = relY * zoomInv - panY * zoomInv
          const canvasWidth = rect.width * zoomInv
          const canvasHeight = rect.height * zoomInv
          
          // æ”¶é›†è°ƒè¯•æ•°æ®
          elementDebugData.push({
            type: element.className,
            rect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height },
            canvas: { x: canvasX, y: canvasY, width: canvasWidth, height: canvasHeight }
          })
          
          // æ›´æ–°æœ€å°å’Œæœ€å¤§è¾¹ç•?          minX = Math.min(minX, canvasX)
          minY = Math.min(minY, canvasY)
          maxX = Math.max(maxX, canvasX + canvasWidth)
          maxY = Math.max(maxY, canvasY + canvasHeight)
        }
      })
      
      // å¯¹äºSVGå…ƒç´ ï¼Œä½¿ç”¨getBBoxè·å–æ›´å‡†ç¡®çš„è¾¹ç•Œ
      const svgElements = vueFlowElement.querySelectorAll('svg')
      svgElements.forEach(svg => {
        try {
          // å¤„ç†SVGå†…çš„è·¯å¾„
          const paths = svg.querySelectorAll('path')
          paths.forEach(path => {
            try {
              const bbox = path.getBBox()
              if (bbox && bbox.width > 0 && bbox.height > 0) {
                // SVGå…ƒç´ çš„ä½ç½®éœ€è¦ä½¿ç”¨SVGåæ ‡ç³»è½¬æ?                const svgRect = svg.getBoundingClientRect()
                const relX = svgRect.left - vueFlowRect.left
                const relY = svgRect.top - vueFlowRect.top
                
                // è®¡ç®—è·¯å¾„ç›¸å¯¹äºç”»å¸ƒçš„ä½ç½®
                const pathX = relX * zoomInv - panX * zoomInv + bbox.x * zoomInv
                const pathY = relY * zoomInv - panY * zoomInv + bbox.y * zoomInv
                const pathWidth = bbox.width * zoomInv
                const pathHeight = bbox.height * zoomInv
                
                // æ›´æ–°è¾¹ç•Œå€?                minX = Math.min(minX, pathX)
                minY = Math.min(minY, pathY)
                maxX = Math.max(maxX, pathX + pathWidth)
                maxY = Math.max(maxY, pathY + pathHeight)
              }
            } catch (e) {
              // å¿½ç•¥æ— æ³•è·å–è¾¹ç•Œçš„è·¯å¾?            }
          })
        } catch (e) {
          // å¿½ç•¥æ— æ³•å¤„ç†çš„SVG
        }
      })
      
      // å†æ¬¡æ£€æŸ¥æ˜¯å¦æ¼æ‰äº†èŠ‚ç‚¹
      getNodes.value.forEach(node => {
        if (node.position) {
          // è·å–èŠ‚ç‚¹å…ƒç´ ä»¥ç¡®å®šå®é™…å°ºå¯?          const nodeElement = document.querySelector(`[data-id="${node.id}"]`)
          if (nodeElement) {
            const rect = nodeElement.getBoundingClientRect()
            const nodeWidth = rect.width * zoomInv
            const nodeHeight = rect.height * zoomInv
            
            // æ›´æ–°è¾¹ç•Œå€?- ä½¿ç”¨èŠ‚ç‚¹åæ ‡
            minX = Math.min(minX, node.position.x)
            minY = Math.min(minY, node.position.y)
            maxX = Math.max(maxX, node.position.x + nodeWidth)
            maxY = Math.max(maxY, node.position.y + nodeHeight)
          }
        }
      })
      
      // æ£€æŸ¥è¾¹åŠå…¶è¿æ¥ç‚?      getEdges.value.forEach(edge => {
        // å°è¯•ç›´æ¥ä½¿ç”¨è¾¹çš„æ•°æ®è·å–é¢å¤–ä¿¡æ¯
        if (edge.sourceNode && edge.targetNode) {
          // è·å–æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„ä½ç½?          const sourcePos = edge.sourceNode.position
          const targetPos = edge.targetNode.position
          
          if (sourcePos && targetPos) {
            // æ›´æ–°è¾¹ç•Œï¼Œç¡®ä¿åŒ…å«è¿æ¥çº¿çš„èµ·ç‚¹å’Œç»ˆç‚¹
            minX = Math.min(minX, sourcePos.x, targetPos.x)
            minY = Math.min(minY, sourcePos.y, targetPos.y)
            maxX = Math.max(maxX, sourcePos.x, targetPos.x)
            maxY = Math.max(maxY, sourcePos.y, targetPos.y)
          }
        }
      })
      
      // è®°å½•è®¡ç®—å‡ºçš„è¾¹ç•Œä¿¡æ¯
      console.log('åŸå§‹è¾¹ç•Œ:', { minX, minY, maxX, maxY })
      
      // ä¸ºè¾¹ç•Œæ·»åŠ å†…è¾¹è·ï¼Œåº•éƒ¨é¢å¤–å¢åŠ æ›´å¤šç©ºé—?      const paddingHorizontal = 30;
      const paddingTop = 30;
      const paddingBottom = 60; // åº•éƒ¨å¢åŠ æ›´å¤šç©ºé—´ï¼Œè§£å†³åº•éƒ¨å†…å®¹ä¸¢å¤±é—®é¢?      minX -= paddingHorizontal;
      minY -= paddingTop;
      maxX += paddingHorizontal;
      maxY += paddingBottom;
    } catch (e) {
      console.warn('è®¡ç®—å†…å®¹è¾¹ç•Œæ—¶å‡ºé”?', e)
    }
    
    // ä¸ºè¾¹ç•Œæ·»åŠ å†…è¾¹è·
    const padding = 30
    minX -= padding
    minY -= padding
    maxX += padding
    maxY += padding + 20 // åº•éƒ¨é¢å¤–å¢åŠ ä¸€äº›ç©ºé—?    
    // è®¡ç®—æµç¨‹å›¾å†…å®¹åŒºåŸŸçš„å®½åº¦å’Œé«˜åº?    const contentWidth = maxX - minX
    const contentHeight = maxY - minY
    
    // å¦‚æœæ²¡æœ‰å†…å®¹ï¼Œæˆ–è®¡ç®—å‡ºçš„è¾¹ç•Œæ— æ•ˆï¼Œåˆ™ä½¿ç”¨æ•´ä¸ªç”»å¸ƒ
    if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY) || 
        contentWidth <= 0 || contentHeight <= 0) {
      console.warn('æ— æ³•è®¡ç®—æœ‰æ•ˆå†…å®¹åŒºåŸŸï¼Œå°†ä½¿ç”¨æ•´ä¸ªç”»å¸ƒ')
      minX = 0
      minY = 0
      maxX = vueFlowElement.clientWidth
      maxY = vueFlowElement.clientHeight
    }
    
    console.log('å¯¼å‡ºåŒºåŸŸ:', { minX, minY, maxX, maxY, width: contentWidth, height: contentHeight })
    
    // ä¿å­˜åŸå§‹è§†å›¾è®¾ç½®
    const originalViewportOverflow = vueFlowElement.style.overflow
    const originalWidth = vueFlowElement.style.width
    const originalHeight = vueFlowElement.style.height

    try {
      // è®¾ç½®transformä»¥é€‚åº”å†…å®¹åŒºåŸŸ
      const flowWrapper = document.querySelector('.vue-flow__transformationpane') as HTMLElement
      if (flowWrapper) {
        const transformX = -minX
        const transformY = -minY
        
        // é‡ç½®transform
        flowWrapper.style.transform = `translate(${transformX}px, ${transformY}px) scale(1)`
      }
      
      // è®¾ç½®å…ƒç´ å®½é«˜ä¸ºå†…å®¹åŒºåŸŸå®½é«?      vueFlowElement.style.width = `${contentWidth}px`
      vueFlowElement.style.height = `${contentHeight}px`
      vueFlowElement.style.overflow = 'hidden'
      
      // ç­‰å¾…DOMæ›´æ–° - ä½¿ç”¨æ›´é•¿çš„ç­‰å¾…æ—¶é—´ç¡®ä¿å®Œå…¨æ¸²æŸ?      console.log('ç­‰å¾…DOMæ›´æ–°...')
      await new Promise<void>((resolve) => setTimeout(resolve, 300))
    } catch (error) {
      console.error('è®¾ç½®transformå¤±è´¥:', error)
    }
    
    // ç›´æ¥è·å–æ‰€æœ‰è¾¹å…ƒç´ 
    const edgeElements = vueFlowElement.querySelectorAll('.vue-flow__edge')
    
    // é¢„å…ˆå¤„ç†æ‰€æœ‰è¾¹çš„æ ·å¼?- è®°å½•åŸå§‹æ ·å¼ä¿¡æ¯
    const edgeOriginalStyles: Map<string, {stroke: string, strokeWidth: string}> = new Map()
    
    edgeElements.forEach(edgeEl => {
      const edgeId = edgeEl.getAttribute('data-id')
      if (edgeId) {
        // è·å–å½“å‰è¾¹çš„è®¡ç®—æ ·å¼
        const computedStyle = window.getComputedStyle(edgeEl)
        
        // è·å–è¾¹çš„åŸå§‹è¾¹ç¼˜å…ƒç´ 
        const edgePath = edgeEl.querySelector('.vue-flow__edge-path')
        if (edgePath) {
          // å°è¯•å¤šç§æ–¹å¼è·å–é¢œè‰²ï¼šç›´æ¥ä»è¾¹å…ƒç´ ã€ä»è·¯å¾„å…ƒç´ ã€ä»æ•°æ®æ¨¡å‹
          let strokeColor = ''
          let strokeWidth = ''
          
          // 1. ä»æ•°æ®æ¨¡å‹ä¸­æŸ¥æ‰¾
          const edgeData = getEdges.value.find(e => e.id === edgeId)
          if (edgeData && edgeData.style) {
            if (typeof edgeData.style === 'object') {
              strokeColor = edgeData.style.stroke as string || ''
              strokeWidth = typeof edgeData.style.strokeWidth === 'number' 
                ? `${edgeData.style.strokeWidth}px` 
                : String(edgeData.style.strokeWidth || '')
            }
          }
          
          // 2. ä»è®¡ç®—æ ·å¼ä¸­è·å–
          if (!strokeColor) {
            strokeColor = computedStyle.stroke || 
                          computedStyle.getPropertyValue('stroke') || 
                          computedStyle.color
          }
          
          if (!strokeWidth) {
            strokeWidth = computedStyle.strokeWidth || 
                          computedStyle.getPropertyValue('stroke-width') || 
                          '2px'
          }
          
          // å­˜å‚¨åŸå§‹æ ·å¼
          edgeOriginalStyles.set(edgeId, {
            stroke: strokeColor !== 'none' && strokeColor !== '' ? strokeColor : '#555',
            strokeWidth: strokeWidth !== 'none' && strokeWidth !== '' ? strokeWidth : '2px'
          })
        }
      }
    })

    // åº”ç”¨SVGå¤„ç†ç›´æ¥åœ¨åŸå§‹DOMä¸?    const svgElements = vueFlowElement.querySelectorAll('svg')
    svgElements.forEach(svg => {
      // ç¡®ä¿SVGå…ƒç´ å¯è§
      svg.style.visibility = 'visible'
      svg.style.display = 'block'
      svg.style.overflow = 'visible'
      
      // å¤„ç†SVGå†…çš„pathå…ƒç´ ï¼Œç‰¹åˆ«å…³æ³¨ConditionNodeçš„è±å½¢èƒŒæ™?      const paths = svg.querySelectorAll('path')
      paths.forEach(path => {
        try {
          // ä¿å­˜åŸå§‹å¡«å……è‰²å’Œè¾¹æ¡†è‰?          const originalFill = path.getAttribute('fill')
          const originalStroke = path.getAttribute('stroke')
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯ConditionNodeçš„è±å½¢èƒŒæ™?          const isDiamondPath = path.parentElement?.classList.contains('diamond-background') || 
                               (path.getAttribute('d')?.includes('M50 5 L95 50 L50 95 L5 50 Z') && 
                                path.closest('.condition-node'))
          
          if (isDiamondPath) {
            // ç¡®ä¿è±å½¢èƒŒæ™¯ä¿æŒå…¶å¡«å……è‰²
            if (originalFill) {
              path.style.fill = originalFill
            }
            
            // ç¡®ä¿è±å½¢è¾¹æ¡†å¯è§
            if (originalStroke) {
              path.style.stroke = originalStroke
            }
          } else if (path.classList.contains('vue-flow__edge-path')) {
            // å¦‚æœæ˜¯è¾¹çº¿è·¯å¾?            path.style.fill = 'none'
            
            // æŸ¥æ‰¾è¾¹ID
            const edgeEl = path.closest('.vue-flow__edge')
            if (edgeEl) {
              const edgeId = edgeEl.getAttribute('data-id')
              if (edgeId && edgeOriginalStyles.has(edgeId)) {
                const originalStyle = edgeOriginalStyles.get(edgeId)
                if (originalStyle) {
                  // åº”ç”¨åŸå§‹é¢œè‰²å’Œç²—ç»?                  path.style.stroke = originalStyle.stroke
                  path.style.strokeWidth = originalStyle.strokeWidth
                }
              } else {
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŸå§‹æ ·å¼ï¼Œä½¿ç”¨è®¡ç®—æ ·å¼?                const computedStyle = window.getComputedStyle(path)
                path.style.stroke = computedStyle.stroke || '#555'
                path.style.strokeWidth = computedStyle.strokeWidth || '2px'
              }
            }
          } else {
            // éè¾¹çº¿è·¯å¾„ä¿æŒåŸæ ?            path.style.fill = path.style.fill || 'none'
            const pathStroke = path.getAttribute('stroke') || 
                              path.style.stroke || 
                              window.getComputedStyle(path).stroke || 
                              'currentColor'
            path.style.stroke = pathStroke
          }
          
          // ç¡®ä¿è™šçº¿æ˜¾ç¤ºæ­£ç¡®
          if (path.getAttribute('stroke-dasharray')) {
            const dashArray = path.getAttribute('stroke-dasharray')
            path.setAttribute('stroke-dasharray', dashArray || '5,5')
          }
        } catch(e) {
          console.warn('å¤„ç†SVGè·¯å¾„æ—¶å‡ºé”?', e)
        }
      })
      
      // å¤„ç†è¾¹ç¼˜æ ‡ç­¾èƒŒæ™¯ - ä¿®å¤é»‘è‰²èƒŒæ™¯é—®é¢˜
      const edgeTextBgs = svg.querySelectorAll('.vue-flow__edge-textbg, .vue-flow__edge-textwrapper rect')
      edgeTextBgs.forEach(rect => {
        if (rect instanceof SVGRectElement) {
          // è®¾ç½®è¾¹ç¼˜æ ‡ç­¾èƒŒæ™¯ä¸ºç™½è‰²å¹¶å¢åŠ é€æ˜åº?          rect.style.fill = '#ffffff'
          rect.style.fillOpacity = '0.8'
          // å®Œå…¨ç§»é™¤è¾¹æ¡†
          rect.style.stroke = 'none'
          rect.style.strokeWidth = '0'
        }
      })
      
      // å¤„ç†è¾¹ç¼˜æ ‡ç­¾æ–‡æœ¬
      const edgeTexts = svg.querySelectorAll('.vue-flow__edge-text, .vue-flow__edge-textwrapper text')
      edgeTexts.forEach(text => {
        if (text instanceof SVGTextElement) {
          // è®¾ç½®è¾¹ç¼˜æ ‡ç­¾æ–‡æœ¬å­—ä½“å¤§å°
          text.style.fontSize = '12px'
          text.style.fontFamily = 'Arial, sans-serif'
        }
      })
      
      // ç¡®ä¿marker (ç®­å¤´) æ­£ç¡®æ˜¾ç¤º
      const markers = svg.querySelectorAll('marker')
      markers.forEach(marker => {
        marker.setAttribute('markerWidth', '15')
        marker.setAttribute('markerHeight', '15')
        
        // æŸ¥æ‰¾markerå†…çš„pathå¹¶è®¾ç½®é¢œè‰?        const markerPaths = marker.querySelectorAll('path')
        markerPaths.forEach(markerPath => {
          // è·å–å¼•ç”¨æ­¤markerçš„è¾¹çš„é¢œè‰?          const markerId = marker.id
          if (markerId) {
            // æŸ¥æ‰¾ä½¿ç”¨æ­¤markerçš„è¾¹
            const edgesWithMarker = document.querySelectorAll(`.vue-flow__edge[marker-end*="${markerId}"], .vue-flow__edge[marker-start*="${markerId}"]`)
            if (edgesWithMarker && edgesWithMarker.length > 0) {
              const edgeWithMarker = edgesWithMarker[0] as HTMLElement
              const edgeId = edgeWithMarker.getAttribute('data-id')
              
              if (edgeId && edgeOriginalStyles.has(edgeId)) {
                const originalStyle = edgeOriginalStyles.get(edgeId)
                if (originalStyle) {
                  // ä¸ºmarker pathåº”ç”¨ç›¸åŒçš„é¢œè‰?                  markerPath.style.fill = originalStyle.stroke
                  markerPath.style.stroke = originalStyle.stroke
                }
              }
            }
          }
        })
      })
    })

    // ç¡®ä¿åœ†å½¢èŠ‚ç‚¹å®Œæ•´æ˜¾ç¤º
    const circleNodes = vueFlowElement.querySelectorAll('.vue-flow__node-circle')
    circleNodes.forEach(node => {
      ;(node as HTMLElement).style.padding = '5px'
    })

    // å¯¼å‡ºå›¾ç‰‡çš„é…ç½®é€‰é¡¹
    const exportImageOptions = {
      quality: 0.98, // æé«˜å¯¼å‡ºè´¨é‡
      backgroundColor: 'white',
      pixelRatio: 2, // å¢åŠ åƒç´ æ¯”ä¾‹ï¼Œæé«˜å›¾ç‰‡æ¸…æ™°åº¦
      filter: (node: HTMLElement) => {
        if (!node || !node.classList) return true;
        
        // æ£€æŸ¥å…ƒç´ æ˜¯å¦åº”è¯¥è¢«è¿‡æ»¤ï¼ˆåŸºäºç±»åï¼‰
        const shouldBeFiltered = [
          'vue-flow__controls', 
          'vue-flow__minimap', 
          'top-toolbar', 
          'node-toolbar', 
          'left-sidebar'
        ].some(className => 
          node.classList.contains(className) || 
          node.closest(`.${className}`)
        );
        
        // ä»…ä¿ç•™ä¸åº”è¢«è¿‡æ»¤çš„å…ƒç´?        return !shouldBeFiltered;
      }
    };

    // æ ¹æ®æ ¼å¼é€‰æ‹©å¯¼å‡ºæ–¹æ³•
    const exportFn = format === 'png' ? toPng : toJpeg
    const extension = format === 'png' ? 'png' : 'jpg'
    
    const dataUrl = await exportFn(vueFlowElement, exportImageOptions)
    
    // å¦‚æœéœ€è¦ä¸‹è½½ï¼Œåˆ›å»ºä¸‹è½½é“¾æ¥
    if (download) {
      const fileName = `flowchart_${getTimestamp()}`
      const link = document.createElement('a')
      link.download = `${fileName}.${extension}`
      link.href = dataUrl
      link.click()
    }
    
    // è¿”å›ç”Ÿæˆçš„æ•°æ®URL
    return dataUrl
  } catch (error) {
    console.error('ç”Ÿæˆå›¾ç‰‡æ•°æ®URLå¤±è´¥:', error)
    return null
  } finally {
    try {
      // ç¡®ä¿æ— è®ºå¦‚ä½•éƒ½æ¢å¤åŸå§‹çŠ¶æ€?      if (vueFlowElement) {
        console.log('æ¢å¤ç”»å¸ƒçŠ¶æ€?, {
          width: originalWidth,
          height: originalHeight,
          overflow: originalViewportOverflow
        })
        
        // æ¢å¤åŸå§‹ç”»å¸ƒå¤§å°å’Œä½ç½?        vueFlowElement.style.width = originalWidth
        vueFlowElement.style.height = originalHeight
        vueFlowElement.style.overflow = originalViewportOverflow || ''
      }
      
      // æ¢å¤åŸå§‹transform
      const flowWrapper = document.querySelector('.vue-flow__transformationpane') as HTMLElement
      if (flowWrapper) {
        flowWrapper.style.transform = `translate(${originalTransform.x || 0}px, ${originalTransform.y || 0}px) scale(${originalTransform.zoom || 1})`
      }
      
      // æ¢å¤åŸå§‹èŠ‚ç‚¹çŠ¶æ€?      setNodes(originalNodes as any)
      setEdges(originalEdges)
      
      // ç§»é™¤é˜²æŠ–åŠ¨ç±»
      document.body.classList.remove('exporting-image')
      
      // å¼ºåˆ¶åˆ·æ–°èŠ‚ç‚¹å†…éƒ¨çŠ¶æ€ï¼Œç‰¹åˆ«æ˜¯ConditionNode
      setTimeout(() => {
        // è·å–æ‰€æœ‰æ¡ä»¶èŠ‚ç‚?        const conditionNodes = getNodes.value.filter(node => node.type === 'condition')
        if (conditionNodes.length > 0) {
          // æ›´æ–°è¿™äº›èŠ‚ç‚¹çš„å†…éƒ¨çŠ¶æ€?          updateNodeInternals(conditionNodes.map(node => node.id))
        }
      }, 50)
    } catch (e) {
      console.error('æ¢å¤ç”»å¸ƒçŠ¶æ€æ—¶å‡ºé”™:', e)
    }
  }
}

/**
 * å¯¼å‡ºæµç¨‹å›¾ä¸ºå›¾ç‰‡
 * @param format è¾“å‡ºæ ¼å¼ï¼?jpg'æˆ?png'
 * @returns Promise<string | null> è¿”å›ç”Ÿæˆçš„dataUrl
 */
const exportImage = async (format: 'jpg' | 'png' = 'jpg'): Promise<string | null> => {
  // åˆ©ç”¨getDataUrlæ–¹æ³•å¹¶è‡ªåŠ¨ä¸‹è½½å›¾ç‰?  return getDataUrl(format, true);
}

/**
 * ä»JSONå¯¹è±¡å¯¼å…¥æµç¨‹å›¾æ•°æ? * @param data æµç¨‹å›¾JSONæ•°æ®å¯¹è±¡
 * @returns Promise<boolean> å¯¼å…¥æ˜¯å¦æˆåŠŸ
 */
const importFlowDataFromJson = async (data: any): Promise<boolean> => {
  try {
    // éªŒè¯æ•°æ®æ ¼å¼
    if (!data || typeof data !== 'object' || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
      alert('æ— æ•ˆçš„æµç¨‹å›¾æ•°æ®æ ¼å¼');
      return false;
    }
    
    // å¤„ç†èŠ‚ç‚¹å’Œè¾¹çš„æ•°æ?    const nodes = data.nodes.map((node: any) => {
      // ç¡®ä¿ä½ç½®ä¿¡æ¯æ­£ç¡®
      const position = {
        x: node.position?.x || 0,
        y: node.position?.y || 0
      };
      
      return {
        ...node,
        position,
        selected: false
      };
    });
    
    const edges = data.edges.map((edge: any) => ({
      ...edge,
      selected: false
    }));
    
    // åº”ç”¨æ•°æ®åˆ°ç”»å¸?    setNodes([]);
    setEdges([]);
    
    // ä½¿ç”¨setTimeoutç¡®ä¿æ¸…ç©ºæ“ä½œå®Œæˆ
    await new Promise<void>(resolve => setTimeout(resolve, 50));
    
    setNodes(nodes);
    setEdges(edges);
    
    return true;
  } catch (error) {
    console.error('å¯¼å…¥æ•°æ®å¤±è´¥:', error);
    alert('å¯¼å…¥æ•°æ®å¤±è´¥ï¼? + (error instanceof Error ? error.message : String(error)));
    return false;
  }
}

/**
 * ä»JSONæ–‡ä»¶å¯¼å…¥æµç¨‹å›¾æ•°æ? * @param file JSONæ–‡ä»¶å¯¹è±¡
 */
const importFlowData = async (file: File): Promise<boolean> => {
  try {
    const fileContent = await file.text();
    const data = JSON.parse(fileContent);
    
    // éªŒè¯æ•°æ®æ ¼å¼
    if (!data || typeof data !== 'object' || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
      alert('æ— æ•ˆçš„æµç¨‹å›¾æ•°æ®æ ¼å¼');
      return false;
    }
    
    // å¤„ç†èŠ‚ç‚¹å’Œè¾¹çš„æ•°æ?    const nodes = data.nodes.map((node: any) => {
      // ç¡®ä¿ä½ç½®ä¿¡æ¯æ­£ç¡®
      const position = {
        x: node.position?.x || 0,
        y: node.position?.y || 0
      };
      
      return {
        ...node,
        position,
        selected: false
      };
    });
    
    const edges = data.edges.map((edge: any) => ({
      ...edge,
      selected: false
    }));
    
    // åº”ç”¨æ•°æ®åˆ°ç”»å¸?    setNodes([]);
    setEdges([]);
    
    // ä½¿ç”¨setTimeoutç¡®ä¿æ¸…ç©ºæ“ä½œå®Œæˆ
    await new Promise<void>(resolve => setTimeout(resolve, 50));
    
    setNodes(nodes);
    setEdges(edges);
    
    return true;
  } catch (error) {
    console.error('å¯¼å…¥æ•°æ®å¤±è´¥:', error);
    alert('å¯¼å…¥æ•°æ®å¤±è´¥ï¼? + (error instanceof Error ? error.message : String(error)));
    return false;
  }
};
/**
 * ä¿å­˜æµç¨‹å›¾æ•°æ®åˆ°JSONå¯¹è±¡çš„æŒ‡å®šå±æ€? * @param targetObject ç›®æ ‡JSONå¯¹è±¡
 * @param propertyPath å±æ€§è·¯å¾?ä¾‹å¦‚ 'flow.data'
 * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
 */
const saveToJsonProperty = (targetObject: any, propertyPath: string): boolean => {
  try {
    if (!targetObject || typeof targetObject !== 'object') {
      throw new Error('ç›®æ ‡å¯¹è±¡æ— æ•ˆ');
    }

    const flowData = getFlowData();
    
    // è§£æå±æ€§è·¯å¾?    const pathParts = propertyPath.split('.');
    let current = targetObject;
    
    // éå†è·¯å¾„ç›´åˆ°æœ€åä¸€ä¸ªå±æ€?    for (let i = 0; i < pathParts.length - 1; i++) {
      const part = pathParts[i];
      if (!(part in current)) {
        current[part] = {};
      }
      current = current[part];
    }
    
    // è®¾ç½®æœ€åä¸€ä¸ªå±æ€§çš„å€?    const lastPart = pathParts[pathParts.length - 1];
    current[lastPart] = flowData;
    
    return true;
  } catch (error) {
    console.error('ä¿å­˜åˆ°JSONå±æ€§å¤±è´?', error);
    alert('ä¿å­˜åˆ°JSONå±æ€§å¤±è´¥ï¼š' + (error instanceof Error ? error.message : String(error)));
    return false;
  }
};


/**
 * ä¿å­˜æµç¨‹å›¾æ•°æ®åˆ°API
 * @param apiEndpoint APIç«¯ç‚¹URL
 * @param options å¯é€‰çš„è¯·æ±‚é…ç½®
 */
const saveToAPI = async (apiEndpoint: string, options?: RequestInit): Promise<boolean> => {
  try {
    const flowData = getFlowData();
    
    // è°ƒç”¨APIä¿å­˜æ•°æ®
    const response = await fetch(apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers
      },
      body: JSON.stringify(flowData),
      ...options
    });
    
    if (!response.ok) {
      throw new Error('ä¿å­˜å¤±è´¥: ' + response.statusText);
    }
    
    return true;
  } catch (error) {
    console.error('ä¿å­˜åˆ°APIå¤±è´¥:', error);
    alert('ä¿å­˜åˆ°APIå¤±è´¥ï¼? + (error instanceof Error ? error.message : String(error)));
    return false;
  }
};

/**
 * ä»APIåŠ è½½æµç¨‹å›¾æ•°æ? * @param apiEndpoint APIç«¯ç‚¹URL
 * @param options å¯é€‰çš„è¯·æ±‚é…ç½®
 */
const loadFromAPI = async (apiEndpoint: string, options?: RequestInit): Promise<boolean> => {
  try {
    const response = await fetch(apiEndpoint, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers
      },
      ...options
    });
    
    if (!response.ok) {
      throw new Error('ä»APIåŠ è½½å¤±è´¥: ' + response.statusText);
    }
    
    const data = await response.json();
    return await importFlowData(new Blob([JSON.stringify(data)], { type: 'application/json' }) as any);
  } catch (error) {
    console.error('ä»APIåŠ è½½å¤±è´¥:', error);
    alert('ä»APIåŠ è½½å¤±è´¥ï¼? + (error instanceof Error ? error.message : String(error)));
    return false;
  }
};

// æš´éœ²æ–¹æ³•ç»™å¤–éƒ¨ä½¿ç”?const flowEditorMethods = {
  getFlowData,
  exportFlowData,
  exportImage,
  importFlowData,
  saveToAPI,
  loadFromAPI,
  processNodeData,
  processEdgeData,
  getDataUrl,
  saveToJsonProperty,
  importFlowDataFromJson,
}

// æä¾›FlowEditorçš„æ–¹æ³•ç»™å­ç»„ä»?provide('flowEditor', flowEditorMethods)

defineExpose(flowEditorMethods)

// è‡ªå®šä¹‰NodeComponentç±»å‹ä»¥è§£å†³ç±»å‹å…¼å®¹æ€§é—®é¢?// ... existing code ...
</script>

<style>
.flow-editor {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  background-color: #FFF;
  position: relative;
  overflow: hidden;
}

.main-content {
  flex: 1;
  display: grid;
  grid-template-columns: 40px 1fr;
  position: relative;
  overflow: hidden;
}

.canvas-container {
  grid-column: 2;
  height: 100%;
  position: relative;
  overflow: hidden;
  will-change: transform;
  transform: translateZ(0);
}

/* é˜²æ­¢å¯¼å‡ºæ—¶çš„å¸ƒå±€å˜åŒ– */
body.exporting-image .main-content {
  grid-template-columns: 40px 1fr !important;
  transition: none !important;
}

.vue-flow-wrapper {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

/* Vue Flow ç›¸å…³æ ·å¼ */
:root {
  --vf-node-bg: #fff;
  --vf-node-text: #222;
  --vf-connection-path: #b1b1b7;
  --vf-handle: #555;
}

.vue-flow__background {
  background-color: #f8f8f8;
}

.vue-flow__background-pattern {
  color: #aaa;
}

.vue-flow__edge {
  stroke-width: 1px !important;
  stroke: #555555 !important;
}

.vue-flow__edge:hover,
.vue-flow__edge:hover .vue-flow__edge-path {
  stroke: #8080FF !important;
}

.vue-flow__edge.animated {
  stroke-dasharray: 5;
  animation: dashdraw 0.5s linear infinite;
}

@keyframes dashdraw {
  from {
    stroke-dashoffset: 10;
  }
}

/* ä¿®æ”¹ç®­å¤´æ ·å¼ */
.vue-flow__edge-path {
  pointer-events: stroke !important;
  cursor: pointer !important;
}

.vue-flow__arrowhead {
  stroke: none !important;
  fill: currentColor !important;
  transform: scale(1.5) !important;
  transform-origin: center !important;
}

.vue-flow__edge.selected .vue-flow__arrowhead {
  fill: #409eff !important;
}

.vue-flow__edge:hover .vue-flow__arrowhead {
  fill: #8080FF !important;
}

/* è°ƒæ•´ç®­å¤´å¤§å°éšçº¿æ¡ç²—ç»†çš„å˜åŒ–æ¯”ä¾‹ */
.vue-flow__edge[style*="stroke-width: 1px"] .vue-flow__arrowhead {
  transform: scale(1.5) !important;
}

.vue-flow__edge[style*="stroke-width: 2px"] .vue-flow__arrowhead {
  transform: scale(1.7) !important;
}

.vue-flow__edge[style*="stroke-width: 3px"] .vue-flow__arrowhead {
  transform: scale(1.9) !important;
}

.vue-flow__edge[style*="stroke-width: 4px"] .vue-flow__arrowhead {
  transform: scale(2.1) !important;
}

.vue-flow__edge[style*="stroke-width: 5px"] .vue-flow__arrowhead {
  transform: scale(2.3) !important;
}

.vue-flow__edge-interaction-path {
  cursor: pointer !important;
  pointer-events: all !important;
  stroke-opacity: 0;
  stroke-width: 25px !important;
}

.vue-flow__edge.edge-selected .vue-flow__edge-path,
.vue-flow__edge.selected .vue-flow__edge-path {
  stroke: #409eff !important;
  filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.3));
}

.resize-handle {
  position: absolute;
  width: 10px;
  height: 10px;
  background: white;
  border: 1px solid #1a192b;
  border-radius: 2px;
  z-index: 10;
  pointer-events: all !important;
}

.nodrag {
  pointer-events: all !important;
}

.vue-flow__node .vue-flow__edge-interaction-path {
  pointer-events: none !important;
}

.vue-flow__node * {
  pointer-events: auto !important;
}

.vue-flow__node.resizing .vue-flow__edge-path {
  pointer-events: none !important;
}

/* è¾¹æ ‡ç­¾æ ·å¼?- å¼ºåŒ–å­—ä½“æ§åˆ¶ï¼Œç¡®ä¿ä¸åŠ ç²— */
.vue-flow__edge text,
.vue-flow__edge .vue-flow__edge-text,
.vue-flow__edge-textwrapper text,
.vue-flow .vue-flow__edge .vue-flow__edge-text {
  font-weight: 400 !important; /* æ˜ç¡®ä½¿ç”¨å¸¸è§„å­—é‡ */
  font-size: 12px !important;
  fill: #333 !important;
  font-family: Arial, sans-serif !important;
  pointer-events: none;
  stroke: none !important; /* ç¡®ä¿æ²¡æœ‰æ–‡å­—æè¾¹ */
  stroke-width: 0 !important;
  text-rendering: geometricPrecision !important; /* æé«˜æ–‡æœ¬æ¸²æŸ“ç²¾åº¦ */
  letter-spacing: normal !important; /* æ­£å¸¸å­—é—´è·?*/
  paint-order: normal !important; /* æ­£å¸¸ç»˜åˆ¶é¡ºåº */
}

/* ä¿ç•™ç™½è‰²èƒŒæ™¯æé«˜å¯è¯»æ€§ï¼Œä½†å»é™¤è¾¹æ¡†å’Œé˜´å½± */
.vue-flow__edge .vue-flow__edge-textbg,
.vue-flow__edge-textwrapper rect,
.vue-flow .vue-flow__edge .vue-flow__edge-textbg {
  fill: white !important;
  stroke: none !important;
  stroke-width: 0 !important;
  filter: none !important;
}

/* æ–‡æœ¬è¾“å…¥æ¡†è‡ªå®šä¹‰æ ·å¼ */
.edge-label-input {
  font-size: 12px;
  color: #555;
  background-color: white;
  border: 1px dotted #555;
  border-radius: 3px;
  text-align: center;
  min-width: 60px;
  height: 24px;
  padding: 0 4px;
  outline: none;
  box-sizing: border-box;
}

/* è¾¹æ ‡ç­¾ç¼–è¾‘å¯¹è¯æ¡†æ ·å¼ */
.edge-label-dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.edge-label-dialog {
  background-color: white;
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  width: 350px;
  max-width: 90%;
  overflow: hidden;
}

.dialog-header {
  padding: 15px 20px;
  border-bottom: 1px solid #eee;
}

.dialog-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 500;
  color: #333;
}

.dialog-body {
  padding: 20px;
}

.label-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
  outline: none;
  box-sizing: border-box;
}

.label-input:focus {
  border-color: #4096ff;
  box-shadow: 0 0 0 2px rgba(64, 150, 255, 0.1);
}

.dialog-footer {
  padding: 15px 20px;
  border-top: 1px solid #eee;
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

.dialog-footer button {
  padding: 6px 16px;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  border: none;
  transition: all 0.3s;
}

.confirm-btn {
  background-color: #1677ff;
  color: white;
}

.confirm-btn:hover {
  background-color: #4096ff;
}

.cancel-btn {
  background-color: #f5f5f5;
  color: #333;
}

.cancel-btn:hover {
  background-color: #e6e6e6;
}

/* SVGå›¾æ ‡èŠ‚ç‚¹ç‰¹æ®Šæ ·å¼ - ä½¿ç”¨æ›´é«˜ä¼˜å…ˆçº§é€‰æ‹©å™¨è¦†ç›–Vue Flowé»˜è®¤æ ·å¼ */
.vue-flow .vue-flow__node.vue-flow__node-svgIcon {
  border: none !important;
  background-color: transparent !important;
  padding: 0 !important;
  box-shadow: none !important;
  border-radius: 0 !important;
}

/* ç¡®ä¿é€‰ä¸­çŠ¶æ€ä¸‹ä¹Ÿæ²¡æœ‰è¾¹æ¡?*/
.vue-flow .vue-flow__node.vue-flow__node-svgIcon.selected,
.vue-flow .vue-flow__node.vue-flow__node-svgIcon:focus,
.vue-flow .vue-flow__node.vue-flow__node-svgIcon:focus-visible {
  border: none !important;
  box-shadow: none !important;
  outline: none !important;
  background-color: transparent !important;
}

.vue-flow .vue-flow__node.vue-flow__node-svgIcon::before,
.vue-flow .vue-flow__node.vue-flow__node-svgIcon::after {
  display: none !important;
}

/* åŒºåŸŸé€‰æ‹©æ¡†æ ·å¼?*/
.selection-area {
  position: absolute;
  border: 2px dashed #6495ed;
  background-color: rgba(100, 149, 237, 0.1);
  pointer-events: none;
  z-index: 1000;
}

/* ç¡®ä¿ç”»å¸ƒå®¹å™¨å®šä½æ­£ç¡® */
.canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
}

.editor-main {
  position: relative;
  flex: 1;
  height: 100%;
}

.flow-canvas {
  width: 100%;
  height: 100%;
}

/* é˜²æ­¢å¯¼å‡ºå›¾ç‰‡æ—¶UIæŠ–åŠ¨ */
body.exporting-image .left-sidebar {
  pointer-events: none !important; /* é˜²æ­¢äº¤äº’ */
  will-change: transform !important; /* ä¼˜åŒ–æ€§èƒ½ */
  transition: none !important; /* ç¦ç”¨æ‰€æœ‰è¿‡æ¸?*/
  /* ä¿æŒå®Œå…¨å¯è§ï¼Œä¸é€æ˜ */
  opacity: 1 !important; 
  visibility: visible !important;
  position: relative !important;
}

body.exporting-image .vue-flow__controls, 
body.exporting-image .vue-flow__minimap, 
body.exporting-image .top-toolbar,
body.exporting-image .node-toolbar {
  pointer-events: none !important; /* é˜²æ­¢äº¤äº’ */
  will-change: transform !important; /* ä¼˜åŒ–æ€§èƒ½ */
  transition: none !important; /* ç¦ç”¨æ‰€æœ‰è¿‡æ¸?*/
  visibility: visible !important; /* ç¡®ä¿å…ƒç´ ä¿æŒå¯è§ */
  opacity: 0.3 !important; /* ä½¿å…ƒç´ åŠé€æ˜è€Œä¸æ˜¯å®Œå…¨æ¶ˆå¤?*/
}

/* å¯¼å‡ºå›¾ç‰‡æ—¶ç¡®ä¿ç”»å¸ƒä½ç½®å›ºå®?*/
body.exporting-image .vue-flow {
  will-change: transform !important; 
  transition: none !important;
  /* ä¿æŒå¯è§ï¼Œä½†ä¸è¦ä¿®æ”¹å…¶ä½ç½?*/
  position: relative !important;
  overflow: visible !important;
}

/* ç¡®ä¿å˜æ¢é¢æ¿ä¹Ÿå›ºå®šï¼Œé˜²æ­¢ç”»å¸ƒæŠ–åŠ¨ */
body.exporting-image .vue-flow__transformationpane {
  will-change: transform !important; 
  transition: none !important;
  /* é‡è¦ï¼šç¡®ä¿åœ¨åŠ¨ç”»è¿‡ç¨‹ä¸­ä¿æŒå…¶ä½ç½® */
  transform-origin: center center !important;
}

/* ç¡®ä¿å·¦ä¾§è¾¹æ ä¸ä¼šæŠ–åŠ¨ */
.left-sidebar {
  position: relative !important;
  z-index: 10 !important;
  will-change: transform !important;
  transform: translateZ(0) !important; /* å¼ºåˆ¶GPUåŠ é€?*/
  transition: none !important; /* ç¦ç”¨æ‰€æœ‰è¿‡æ¸¡æ•ˆæ?*/
  box-shadow: none !important; /* ç§»é™¤å¯èƒ½å¼•èµ·é‡ç»˜çš„é˜´å½?*/
}

/* ç¨³å®šåŒ–Vue Flowå®¹å™¨ */
.vue-flow {
  will-change: transform !important;
  transform: translateZ(0) !important; /* å¼ºåˆ¶GPUåŠ é€?*/
  position: relative !important; /* ç¡®ä¿å®¹å™¨ä½ç½®ç¨³å®š */
  overflow: visible !important; /* é˜²æ­¢å› æº¢å‡ºå¤„ç†å¼•èµ·çš„è§†è§‰å˜åŒ– */
}

/* ç¨³å®šåŒ–å˜æ¢é¢æ?*/
.vue-flow__transformationpane {
  will-change: transform !important;
  backface-visibility: hidden !important; /* å‡å°‘3Då˜æ¢æ—¶çš„è§†è§‰æŠ–åŠ¨ */
  transform-style: preserve-3d !important; /* ä¼˜åŒ–3Då˜æ¢ */
}

/* ä¼˜åŒ–å¯¼å‡ºè¿‡ç¨‹: 
   1. åˆ›å»ºä¸€ä¸ªè¦†ç›–å±‚ï¼Œé®æŒ¡å¯èƒ½çš„è§†è§‰å˜åŒ–
   2. ä½¿ç”¨CSSåŠ¨ç”»æ¥å¹³æ»‘è¿‡æ¸?
*/
body.exporting-image::after {
  content: "";
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(255, 255, 255, 0.01); /* å‡ ä¹é€æ˜çš„é®ç½?*/
  z-index: 9999; /* ç½®äºæœ€ä¸Šå±‚ */
  pointer-events: none; /* ä¸é˜»æ­¢äº¤äº?*/
  animation: fade-in-out 1s ease-in-out; /* å¹³æ»‘è¿‡æ¸¡ */
}

@keyframes fade-in-out {
  0% { opacity: 0; }
  50% { opacity: 0.05; } /* è½»å¾®çš„é—ªçƒæ•ˆæœåˆ†æ•£æ³¨æ„åŠ› */
  100% { opacity: 0; }
}
</style>
